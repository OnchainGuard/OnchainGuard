[
    {
        "id": 1,
        "category": "Attacker's Mindset",
        "leafId": 0,
        "description": "General check items for main attack types.",
        "isLeaf": false,
        "hasNoLeaf": false,
        "question": "",
        "remediation": "",
        "referenceList": [],
        "childs": [
            {
                "id": 2,
                "category": "Reentrancy Attack",
                "leafId": 0,
                "description": "An attacker exploits a contract's logic to repeatedly call into a function before the previous invocation is complete, potentially draining funds.",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 3,
                        "category": "SOL-AM-ReentrancyAttack",
                        "leafId": 2,
                        "description": "Untrusted external contract calls could callback leading to unexpected results such as multiple withdrawals or out-of-order events.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there any state change after interaction to an external contract?",
                        "remediation": "Use check-effects-interactions pattern or reentrancy guards.",
                        "referenceList": [
                            "https://www.geeksforgeeks.org/reentrancy-attack-in-smart-contracts/",
                            "https://solodit.xyz/issues/m-09-malicious-royalty-recipient-can-steal-excess-eth-from-buy-orders-code4rena-caviar-caviar-private-pools-git",
                            "https://solodit.xyz/issues/h-01-re-entrancy-in-settleauction-allow-stealing-all-funds-code4rena-kuiper-kuiper-contest-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 4,
                        "category": "SOL-AM-ReentrancyAttack",
                        "leafId": 1,
                        "description": "Read-only reentrancy. The read-only reentrancy is a reentrancy scenario where a view function is reentered, which in most cases is unguarded as it does not modify the contract's state. However, if the state is inconsistent, wrong values could be reported. Other protocols relying on a return value can be tricked into reading the wrong state to perform unwanted actions.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there a view function that can return a stale value during interactions?",
                        "remediation": "Extend the reentrancy guard to the view functions as well.",
                        "referenceList": [
                            "https://medium.com/@zokyo.io/read-only-reentrancy-attacks-understanding-the-threat-to-your-smart-contracts-99444c0a7334",
                            "https://solodit.xyz/issues/m-03-read-only-reentrancy-is-possible-code4rena-angle-protocol-angle-protocol-invitational-git",
                            "https://solodit.xyz/issues/h-13-balancerpairoracle-can-be-manipulated-using-read-only-reentrancy-sherlock-none-blueberry-update-git"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 5,
                "category": "Denial-Of-Service(DOS) Attack",
                "leafId": 0,
                "description": "Attackers overload a system, making it unavailable to legitimate users, often by exploiting design vulnerabilities or resource limitations.",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 6,
                        "category": "SOL-AM-DOSA",
                        "leafId": 1,
                        "description": "To prevent denial of service attacks during withdrawals, it's critical to follow the withdrawal pattern best practices - pull based approach.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the withdrawal pattern followed to prevent denial of service?",
                        "remediation": "Implement withdrawal pattern best practices to ensure that contract behavior remains predictable and robust against denial of service attacks.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-06-denial-of-service-contract-owner-could-block-users-from-withdrawing-their-strike-code4rena-putty-putty-contest-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 8,
                        "category": "SOL-AM-DOSA",
                        "leafId": 2,
                        "description": "Enforcing a minimum transaction amount can prevent attackers from clogging the network with zero amount or dust transactions.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there a minimum transaction amount enforced?",
                        "remediation": "Disallow transactions below a certain threshold to maintain efficiency and prevent denial of service through dust spamming.",
                        "referenceList": [
                            "https://solodit.xyz/issues/h-02-denial-of-service-code4rena-hubble-hubble-contest-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 9,
                        "category": "SOL-AM-DOSA",
                        "leafId": 3,
                        "description": "Tokens with blacklisting capabilities, such as USDC, can pose unique risks and challenges to protocols.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "How does the protocol handle tokens with blacklisting functionality?",
                        "remediation": "Account for the possibility of blacklisting within token protocols to ensure continued functionality even if certain addresses are blacklisted.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 10,
                        "category": "SOL-AM-DOSA",
                        "leafId": 4,
                        "description": "Forcing protocols to process queues, like a queue of dust withdrawals, can be exploited to cause a denial of service.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can forcing the protocol to process a queue lead to DOS?",
                        "remediation": "Design queue processing in a manner that is resilient to spam and cannot be exploited to cause denial of service.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 11,
                        "category": "SOL-AM-DOSA",
                        "leafId": 5,
                        "description": "Tokens with low decimals can present issues where the transaction process fails due to rounding to zero amounts.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "What happens with low decimal tokens that might cause DOS?",
                        "remediation": "Implement logic to handle low decimal tokens in a way that prevents the transaction process from breaking due to insufficient token amounts.",
                        "referenceList": [
                            "https://solodit.xyz/issues/potential-funds-locked-due-low-token-decimal-and-long-stream-duration-spearbit-locke-pdf"
                        ],
                        "childs": []
                    },
                    {
                        "id": 7,
                        "category": "SOL-AM-DOSA",
                        "leafId": 6,
                        "description": "Protocols must handle interactions with external contracts in a way that does not compromise their functionality if external dependencies fail.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol handle external contract interactions safely?",
                        "remediation": "Ensure robust handling of external contract interactions to maintain protocol integrity regardless of external contract performance.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-09-unhandled-chainlink-revert-would-lock-all-price-oracle-access-code4rena-juicebox-juicebox-v2-contest-git"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 12,
                "category": "Griefing Attack",
                "leafId": 0,
                "description": "Malicious actors intentionally cause harm to a system, often without direct profit for themselves, just to disrupt its operations or users.",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 382,
                        "category": "SOL-AM-GA",
                        "leafId": 1,
                        "description": "Malicious actors can prevent normal user transactions by making a slight change on the on-chain states. More problematic on L2 chains where tx fee is low.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there an external function that relies on states that can be changed by others?",
                        "remediation": "Ensure normal user actions especially important actions like withdrawal/repayment are not disturbed by other actors.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-10-griefing-attack-to-block-withdraws-code4rena-mochi-mochi-contest-git"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 13,
                "category": "Replay Attack",
                "leafId": 0,
                "description": "Attackers resend or duplicate valid data/signature transmissions to deceive or impersonate another entity.",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 14,
                        "category": "SOL-AM-ReplayAttack",
                        "leafId": 1,
                        "description": "Failed transactions can be susceptible to replay attacks if not properly protected.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are there protections against replay attacks for failed transactions?",
                        "remediation": "Implement nonce-based or other mechanisms to ensure that each transaction can only be executed once, preventing replay attacks.",
                        "referenceList": [
                            "https://github.com/code-423n4/2022-03-rolla-findings/issues/45"
                        ],
                        "childs": []
                    },
                    {
                        "id": 15,
                        "category": "SOL-AM-ReplayAttack",
                        "leafId": 2,
                        "description": "Signatures valid on one chain may be replayed on another, leading to potential security breaches.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there protection against replaying signatures on different chains?",
                        "remediation": "Use chain-specific parameters or domain separators to ensure signatures are only valid on the intended chain.",
                        "referenceList": [
                            "https://github.com/sherlock-audit/2022-09-harpie-judging/blob/main/004-M/004-m.md"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 16,
                "category": "Price Manipulation Attack",
                "leafId": 0,
                "description": "Malicious actors intentionally alter the price of assets on decentralized exchanges, usually to exploit dependent contracts or trades.",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 383,
                        "category": "SOL-AM-PMA",
                        "leafId": 1,
                        "description": "Price, or rates between assets more generally, can be manipulated if it is derived from the ratio of balance. Flash loan and donation are the well-known attack vectors used to manipulate the prices.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "How does the protocol get the price of assets?",
                        "remediation": "Use the Chainlink oracles for the asset prices and implement internal accounting instead of relying on `balanceOf`.",
                        "referenceList": [
                            "https://solodit.xyz/issues/h-05-flash-loan-price-manipulation-in-purchasepyroflan-code4rena-behodler-behodler-contest-git",
                            "https://solodit.xyz/issues/h-05-underlying-assets-stealing-in-autopxgmx-and-autopxglp-via-share-price-manipulation-code4rena-redacted-cartel-redacted-cartel-contest-git",
                            "https://solodit.xyz/issues/h-02-use-of-slot0-to-get-sqrtpricelimitx96-can-lead-to-price-manipulation-code4rena-maia-dao-ecosystem-maia-dao-ecosystem-git"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 17,
                "category": "Donation Attack",
                "leafId": 0,
                "description": "An attacker sends some amount of cryptocurrency to a contract and makes the protocol accounting reaches to an unexpected state.",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 381,
                        "category": "SOL-AM-DA",
                        "leafId": 1,
                        "description": "Attackers can manipulate the accounting by donating tokens.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol rely on `balance` or `balanceOf` instead of internal accounting?",
                        "remediation": "Implement internal accounting instead of relying on `balanceOf` natively.",
                        "referenceList": [
                            "https://solodit.xyz/issues/h-02-first-depositor-can-break-minting-of-shares-code4rena-prepo-prepo-contest-git"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 19,
                "category": "Front-running Attack",
                "leafId": 0,
                "description": "Attackers watch pending transactions and then push their own transaction with a higher gas fee, ensuring it's executed before the targeted transaction.",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 20,
                        "category": "SOL-AM-FrA",
                        "leafId": 1,
                        "description": "Get-or-create pattern functionality is prone to frontrunning attacks.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are there measures in place to prevent frontrunning vulnerabilities in get-or-create patterns?",
                        "remediation": "Ensure the frontrunning does not cause user loss or unexpected problems.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 21,
                        "category": "SOL-AM-FrA",
                        "leafId": 2,
                        "description": "Actions that require two separate transactions may be at risk of frontrunning, where an attacker can intervene between the two calls.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are two-transaction actions designed to be safe from frontrunning?",
                        "remediation": "Ensure critical actions that are split across multiple transactions cannot be interfered with by attackers. This can involve checks or locks between the transactions.",
                        "referenceList": [
                            "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/47"
                        ],
                        "childs": []
                    },
                    {
                        "id": 22,
                        "category": "SOL-AM-FrA",
                        "leafId": 3,
                        "description": "Attackers may cause legitimate transactions to fail by front-running with transactions of negligible amounts.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can users maliciously cause others' transactions to revert by preempting with dust?",
                        "remediation": "Implement checks to prevent transactions with non-material amounts from affecting the contract's state or execution flow.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-12-attacker-can-grift-syndicate-staking-by-staking-a-small-amount-code4rena-stakehouse-protocol-lsd-network-stakehouse-contest-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 23,
                        "category": "SOL-AM-FrA",
                        "leafId": 4,
                        "description": "Without a commit-reveal scheme, actions such as votes or bids are exposed in the mempool before they are mined, allowing adversaries to see and potentially act on this information. The commit-reveal pattern maintains confidentiality until all commitments are made.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol need a commit-reveal scheme?",
                        "remediation": "Implement a commit-reveal scheme where users first commit a hash of their intended action and then reveal the actual action after the commitment phase is over. This protects against front-running and provides a fairer process.",
                        "referenceList": [],
                        "childs": []
                    }
                ]
            },
            {
                "id": 24,
                "category": "Sybil Attack",
                "leafId": 0,
                "description": "A single adversary controls multiple nodes in a network, primarily to subvert its functionality or to gather more than their fair share of resources.",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 386,
                        "category": "SOL-AM-SybilAttack",
                        "leafId": 1,
                        "description": "It is very easy to trigger actions using a lot of alternative addresses on blockchain. Any quorum mechanism or utilization based rewarding system can be vulnerable to sybil attacks.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there a mechanism depending on the number of users?",
                        "remediation": "Do not rely on the number of users in quorum design.",
                        "referenceList": [
                            "https://solodit.xyz/issues/h-7-sybil-on-withdrawal-requests-can-allow-leverage-factor-manipulation-with-flashloans-sherlock-carapace-carapace-git",
                            "https://solodit.xyz/issues/routers-can-sybil-attack-the-sponsor-vault-to-drain-funds-spearbit-connext-pdf",
                            "https://solodit.xyz/issues/h-5-staker-rewards-can-be-gathered-with-maximal-multiplier-no-matter-how-borrowers-are-overdue-sherlock-union-finance-union-finance-git"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 25,
                "category": "Miner Attack",
                "leafId": 0,
                "description": "Miners, who validate and add transactions to the blockchain, manipulate block attributes like hash or timestamp to influence contract execution or outcomes.",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 26,
                        "category": "SOL-AM-MA",
                        "leafId": 1,
                        "description": "`block.timestamp` can be manipulated by miners to a small extent, so relying on it for precise timing might be risky.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is `block.timestamp` used judiciously, especially for longer intervals?",
                        "remediation": "Use `block.timestamp` only where a slight inaccuracy is acceptable, such as for longer intervals.",
                        "referenceList": [],
                        "childs": []
                    }
                ]
            },
            {
                "id": 27,
                "category": "Rug Pull",
                "leafId": 0,
                "description": "Developers or initial project backers abruptly withdraw their funds from a decentralized project or application, often leaving other investors at a loss.",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 384,
                        "category": "SOL-AM-RP",
                        "leafId": 1,
                        "description": "Some protocols grant an admin with a privilege of pulling assets directly from the protocol. In general, if there is an actor that can affect the user funds directly it must be reported.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can the admin of the protocol pull assets from the protocol?",
                        "remediation": "Allow access to only the relevant parts of protocol funds, e.g. by tracking fees internally. Forcing a timelock on the admin actions can be another mitigation.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-06-centralisation-risk-admin-role-of-tokenmanagereth-can-rug-pull-all-eth-from-the-bridge-code4rena-skale-skale-contest-git"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 18,
                "category": "Sandwich Attack",
                "leafId": 0,
                "description": "Malicious actors identify a target transaction on the blockchain, and place their own before and after it, capitalizing on potentially advantageous order execution.",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 385,
                        "category": "SOL-AM-SandwichAttack",
                        "leafId": 1,
                        "description": "An attacker can monitor the mempool and puts two transactions before and after the user's transaction. For example, when an attacker spots a large trade, executes their own trade first to manipulate the price, and then profits by closing their position after the user's trade is executed.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol have an explicit slippage protection on user interactions?",
                        "remediation": "Allow users to specify the minimum output amount and revert the transaction if it is not satisfied.",
                        "referenceList": [
                            "https://solodit.xyz/issues/h-12-sandwich-attack-to-accruepremiumandexpireprotections-sherlock-carapace-carapace-git",
                            "https://solodit.xyz/issues/h-1-adversary-can-sandwich-oracle-updates-to-exploit-vault-sherlock-olympus-olympus-update-git"
                        ],
                        "childs": []
                    }
                ]
            }
        ]
    },
    {
        "id": 28,
        "category": "Basics",
        "leafId": 0,
        "description": "",
        "isLeaf": false,
        "hasNoLeaf": false,
        "question": "",
        "remediation": "",
        "referenceList": [],
        "childs": [
            {
                "id": 29,
                "category": "Version Issues",
                "leafId": 0,
                "description": "Vulnerabilities related to versions.",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 30,
                        "category": "Solidity Version Issues",
                        "leafId": 0,
                        "description": "Vulnerabilities related to specific Solidity versions.",
                        "isLeaf": false,
                        "hasNoLeaf": false,
                        "question": "",
                        "remediation": "",
                        "referenceList": [],
                        "childs": [
                            {
                                "id": 77,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 2,
                                "description": "If an empty string is used in a function call, the following function arguments will not be correctly passed to the function.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Are there any instances where empty strings are directly passed to function calls? (version ~0.4.11)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 78,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 3,
                                "description": "In some situations, the optimizer replaces certain numbers in the code with routines that compute different numbers.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the optimizer replace specific constants with alternative computations? (version ~0.4.10)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2017/05/03/solidity-optimizer-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 48,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 19,
                                "description": "Function calls to internal library functions with calldata parameters called via ``using for`` can result in invalid data being read.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use internal library functions with calldata parameters via `using for`? (version =0.6.9)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 66,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 1,
                                "description": "Storage structs and arrays with types shorter than 32 bytes can cause data corruption if encoded directly from storage using the experimental ABIEncoderV2.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract encode storage structs or arrays with types under 32 bytes directly using experimental ABIEncoderV2? (version 0.5.0~0.5.6)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 32,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 5,
                                "description": "Optimizer sequences containing FullInliner do not preserve the evaluation order of arguments of inlined function calls in code that is not in expression-split form.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "BUILD: Is the contract optimized using sequences containing FullInliner with non-expression-split code? (version 0.6.7~0.8.20)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2023/07/19/full-inliner-non-expression-split-argument-evaluation-order-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 35,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 7,
                                "description": "ABI-encoding a tuple with a statically-sized calldata array in the last component would corrupt 32 leading bytes of its first dynamically encoded component.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Are tuples containing a statically-sized calldata array at the end being ABI-encoded? (version 0.5.8~0.8.15)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2022/08/08/calldata-tuple-reencoding-head-overflow-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 36,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 8,
                                "description": "Copying ``bytes`` arrays from memory or calldata to storage may result in dirty storage values.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract have functions that copy `bytes` arrays from memory or calldata directly to storage? (version 0.0.1~0.8.14)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2022/06/15/dirty-bytes-array-to-storage-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 37,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 9,
                                "description": "The Yul optimizer may incorrectly remove memory writes from inline assembly blocks, that do not access solidity variables.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is there a function with multiple inline assembly blocks? (version 0.8.13~0.8.14)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2022/06/15/inline-assembly-memory-side-effects-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 40,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 11,
                                "description": "Literals used for a fixed length bytes parameter in ``abi.encodeCall`` were encoded incorrectly.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is `abi.encodeCall` used together with fixed-length bytes literals? (version 0.8.11~0.8.12)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2022/03/16/encodecall-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 41,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 12,
                                "description": "User defined value types with underlying type shorter than 32 bytes used incorrect storage layout and wasted storage",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is there any user defined types based on types shorter than 32 bytes? (version =0.8.8)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2021/09/29/user-defined-value-types-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 42,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 13,
                                "description": "Immutable variables of signed integer type shorter than 256 bits can lead to values with invalid higher order bits if inline assembly is used.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is there an immutable variable of signed integer type shorter than 256 bits? (version 0.6.5~0.8.8)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2021/09/29/signed-immutables-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 43,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 14,
                                "description": "If used on memory byte arrays, result of the function ``abi.decode`` can depend on the contents of memory outside of the actual byte array that is decoded.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is there any use of `abi.encode` on memory with multi-dimensional array or structs? (version 0.4.16~0.8.3)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2021/04/21/decoding-from-memory-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 44,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 15,
                                "description": "The bytecode optimizer incorrectly re-used previously evaluated Keccak-256 hashes. You are unlikely to be affected if you do not compute Keccak-256 hashes in inline assembly.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is there an inline assembly block with `keccak256` inside? (version ~0.8.2)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2021/03/23/keccak-optimizer-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 45,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 16,
                                "description": "Copying an empty byte array (or string) from memory or calldata to storage can result in data corruption if the target array's length is increased subsequently without storing new data.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is there a copy of an empty `bytes` or `string` from `memory` or `calldata` to `storage`? (version ~0.7.3)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2020/10/19/empty-byte-array-copy-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 46,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 17,
                                "description": "When assigning a dynamically-sized array with types of size at most 16 bytes in storage causing the assigned array to shrink, some parts of deleted slots were not zeroed out.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is there a dynamically-sized storage-array with types of size at most 16 bytes? (version ~0.7.2)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2020/10/07/solidity-dynamic-array-cleanup-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 64,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 18,
                                "description": "Contract types used in events in libraries cause an incorrect event signature hash",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the library use contract types in events? (version 0.5.0~0.5.7)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 34,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 6,
                                "description": "Calling functions that conditionally terminate the external EVM call using the assembly statements ``return(...)`` or ``stop()`` may result in incorrect removals of prior storage writes.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Are there any functions that conditionally terminate inside an inline assembly? (version 0.8.13~0.8.16)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2022/09/08/storage-write-removal-before-conditional-termination/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 39,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 10,
                                "description": "ABI-reencoding of nested dynamic calldata arrays did not always perform proper size checks against the size of calldata and could read beyond `calldatasize()`.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is a nested array being ABI-encoded or passed directly to an external function? (version 0.5.8~0.8.13)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2022/05/17/calldata-reencode-size-check-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 49,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 20,
                                "description": "String literals containing double backslash characters passed directly to external or encoding function calls can lead to a different string being used when ABIEncoderV2 is enabled.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Are string literals with double backslashes passed directly to external or encoding functions with ABIEncoderV2 enabled? (version 0.5.14~0.6.7)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 50,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 21,
                                "description": "Accessing array slices of arrays with dynamically encoded base types (e.g. multi-dimensional arrays) can result in invalid data being read.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract access slices of dynamic arrays, especially multi-dimensional ones? (version 0.6.0~0.6.7)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 51,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 22,
                                "description": "The creation code of a contract that does not define a constructor but has a base that does define a constructor did not revert for calls with non-zero value.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is there a contract with creation code, no constructor, but a base with a constructor that accepts non-zero values? (version 0.4.5~0.6.7)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 53,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 23,
                                "description": "The creation of very large memory arrays can result in overlapping memory regions and thus memory corruption.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract create extremely large memory arrays? (version 0.2.0~0.6.4)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2020/04/06/memory-creation-overflow-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 54,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 24,
                                "description": "The Yul optimizer can remove essential assignments to variables declared inside for loops when Yul's continue or break statement is used. You are unlikely to be affected if you do not use inline assembly with for loops and continue and break statements.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract's inline assembly with Yul optimizer use assignments inside for loops combined with continue or break? (version =0.6.0)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 55,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 25,
                                "description": "Private methods can be overridden by inheriting contracts.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract allow private methods to be overridden by inheriting contracts? (version 0.3.0~0.5.16)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 56,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 26,
                                "description": "The Yul optimizer can remove essential assignments to variables declared inside for loops when Yul's continue or break statement is used. You are unlikely to be affected if you do not use inline assembly with for loops and continue and break statements.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is there any Yul's continue or break statement inside the loop?? (version 0.5.8~0.5.15)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 57,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 27,
                                "description": "If both the experimental ABIEncoderV2 and the experimental Yul optimizer are activated, one component of the Yul optimizer may reuse data in memory that has been changed in the meantime.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Are both experimental ABIEncoderV2 and Yul optimizer activated? (version =0.5.14)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 58,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 28,
                                "description": "Reading from calldata structs that contain dynamically encoded, but statically-sized members can result in incorrect values.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract read from calldata structs with dynamic yet statically-sized members? (version 0.5.6~0.5.10)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 59,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 29,
                                "description": "Assigning an array of signed integers to a storage array of different type can lead to data corruption in that array.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract assign arrays of signed integers to differently typed storage arrays? (version 0.4.7~0.5.9)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2019/06/25/solidity-storage-array-bugs/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 60,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 30,
                                "description": "Storage arrays containing structs or other statically-sized arrays are not read properly when directly encoded in external function calls or in abi.encode*.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract directly encode storage arrays with structs or static arrays in external calls or abi.encode*? (version 0.4.16~0.5.9)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2019/06/25/solidity-storage-array-bugs/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 61,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 31,
                                "description": "A contract's constructor that takes structs or arrays that contain dynamically-sized arrays reverts or decodes to invalid data.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract's constructor accept structs or arrays with dynamic arrays? (version 0.4.16~0.5.8)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 63,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 33,
                                "description": "Calling uninitialized internal function pointers created in the constructor does not always revert and can cause unexpected behavior.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Are uninitialized internal function pointers created in the constructor being called? (version 0.4.5~0.4.25)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 62,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 32,
                                "description": "Calling uninitialized internal function pointers created in the constructor does not always revert and can cause unexpected behavior.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Are uninitialized internal function pointers created in the constructor being called? (version 0.5.0~0.5.7)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 65,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 34,
                                "description": "Contract types used in events in libraries cause an incorrect event signature hash",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the library use contract types in events? (version 0.3.0~0.4.25)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 67,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 35,
                                "description": "Storage structs and arrays with types shorter than 32 bytes can cause data corruption if encoded directly from storage using the experimental ABIEncoderV2.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract encode storage structs or arrays with types under 32 bytes directly using experimental ABIEncoderV2? (version 0.4.19~0.4.25)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 68,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 36,
                                "description": "The optimizer incorrectly handles byte opcodes whose second argument is 31 or a constant expression that evaluates to 31. This can result in unexpected values.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract's optimizer handle byte opcodes with a second argument of 31 or an equivalent constant expression? (version 0.5.5~0.5.6)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 69,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 37,
                                "description": "Double bitwise shifts by large constants whose sum overflows 256 bits can result in unexpected values.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Are there double bitwise shifts with large constants that might sum up to overflow 256 bits? (version =0.5.5)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 70,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 38,
                                "description": "Using the ** operator with an exponent of type shorter than 256 bits can result in unexpected values.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is the ** operator used with an exponent type shorter than 256 bits? (version ~0.4.24)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2018/09/13/solidity-bugfix-release/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 71,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 39,
                                "description": "Using structs in events logged wrong data.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Are structs used in the logged events? (version 0.4.17~0.4.24)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2018/09/13/solidity-bugfix-release/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 72,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 40,
                                "description": "Calling functions that return multi-dimensional fixed-size arrays can result in memory corruption.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Are functions returning multi-dimensional fixed-size arrays called? (version 0.1.4~0.4.21)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2018/09/13/solidity-bugfix-release/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 73,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 41,
                                "description": "If a contract has both a new-style constructor (using the constructor keyword) and an old-style constructor (a function with the same name as the contract) at the same time, one of them will be ignored.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use both new-style and old-style constructors simultaneously? (version =0.4.22)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 74,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 42,
                                "description": "It is possible to craft the name of a function such that it is executed instead of the fallback function in very specific circumstances.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is there a function name crafted to potentially override the fallback function execution? (version ~0.4.17)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 75,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 43,
                                "description": "The low-level .delegatecall() does not return the execution outcome, but converts the value returned by the functioned called to a boolean instead.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is the low-level .delegatecall() used without checking the actual execution outcome? (version 0.3.0~0.4.14)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 76,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 44,
                                "description": "The ecrecover() builtin can return garbage for malformed input.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is the ecrecover() function used without validating its input? (version ~0.4.13)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 33,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 45,
                                "description": "Accessing the ``.selector`` member on complex expressions leaves the expression unevaluated in the legacy code generation.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is the `.selector` member accessed on complex expressions? (version 0.6.2~0.8.20)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2023/07/19/missing-side-effects-on-selector-access-bug/"
                                ],
                                "childs": []
                            },
                            {
                                "id": 47,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 47,
                                "description": "The compiler does not flag an error when two or more free functions with the same name and parameter types are defined in a source unit or when an imported free function alias shadows another free function with a different name but identical parameter types.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Are there any functions with the same name and parameter type inside the same contract? (version =0.7.1)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 52,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 48,
                                "description": "Tuple assignments with components that occupy several stack slots, i.e. nested tuples, pointers to external functions or references to dynamically sized calldata arrays, can result in invalid values.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use tuple assignments with multi-stack-slot components, like nested tuples or dynamic calldata references? (version 0.1.6~0.6.5)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 31,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 4,
                                "description": "If you use `keccak256(abi.encodePacked(a, b))` and both `a` and `b` are dynamic types, it is easy to craft collisions in the hash value by moving parts of `a` into `b` and vice-versa. More specifically, `abi.encodePacked(\\'a\\', \\'bc\\') == abi.encodePacked(\\'ab\\', \\'c\\').",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use `abi.encodePacked`, especially in hash generation? (version >= 0.8.17)",
                                "remediation": "Use `abi.encode` instead of `abi.encodePacked`.",
                                "referenceList": [
                                    "https://solodit.xyz/issues/m-1-abiencodepacked-allows-hash-collision-sherlock-nftport-nftport-git",
                                    "https://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode"
                                ],
                                "childs": []
                            },
                            {
                                "id": 38,
                                "category": "SOL-Basics-VI-SVI",
                                "leafId": 46,
                                "description": "It was possible to change the data location of the parameters or return variables from ``calldata`` to ``memory`` and vice-versa while overriding internal and public functions. This caused invalid code to be generated when calling such a function internally through virtual function calls.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is there any inconsistency (`memory` vs `calldata`) in the param type during inheritance? (version 0.6.9~0.8.13)",
                                "remediation": "Use the latest Solidity version.",
                                "referenceList": [
                                    "https://blog.soliditylang.org/2022/05/17/data-location-inheritance-bug/"
                                ],
                                "childs": []
                            }
                        ]
                    },
                    {
                        "id": 79,
                        "category": "EIP Adoption Issues",
                        "leafId": 0,
                        "description": "Vulnerabilities related to specific EIP.",
                        "isLeaf": false,
                        "hasNoLeaf": false,
                        "question": "",
                        "remediation": "",
                        "referenceList": [],
                        "childs": [
                            {
                                "id": 80,
                                "category": "SOL-Basics-VI-EAI",
                                "leafId": 1,
                                "description": "`selfdestruct` will not be available after EIP-4758. This EIP will rename the SELFDESTRUCT opcode and replace its functionality.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "EIP-4758: Does the contract use `selfdestruct()`?",
                                "remediation": "Do not use `selfdestruct` to ensure the contract works in the future.",
                                "referenceList": [
                                    "https://eips.ethereum.org/EIPS/eip-4758",
                                    "https://solodit.xyz/issues/m-09-selfdestruct-will-not-be-available-after-eip-4758-code4rena-escher-escher-contest-git",
                                    "https://solodit.xyz/issues/m-03-system-will-not-work-anymore-after-eip-4758-code4rena-axelar-network-axelar-network-git"
                                ],
                                "childs": []
                            }
                        ]
                    },
                    {
                        "id": 81,
                        "category": "OpenZeppelin Version Issues",
                        "leafId": 0,
                        "description": "Vulnerabilities related to specific OpenZeppelin versions.",
                        "isLeaf": false,
                        "hasNoLeaf": false,
                        "question": "",
                        "remediation": "",
                        "referenceList": [],
                        "childs": [
                            {
                                "id": 82,
                                "category": "SOL-Basics-VI-OVI",
                                "leafId": 1,
                                "description": "`ERC2771Context._msgData()` reverts if `msg.data.length < 20`. The correct behavior is not specified in ERC-2771, but based on the specified behavior of `_msgSender` we assume the full `msg.data` should be returned in this case.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use `ERC2771Context`? (version >=4.0.0 <4.9.3)",
                                "remediation": "Use the latest stable OpenZeppelin version",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 88,
                                "category": "SOL-Basics-VI-OVI",
                                "leafId": 3,
                                "description": "ECDSA signature malleability. The functions ECDSA.recover and ECDSA.tryRecover are vulnerable to a kind of signature malleability due to accepting EIP-2098 compact signatures in addition to the traditional 65 byte signature format. This is only an issue for the functions that take a single bytes argument, and not the functions that take r, v, s or r, vs as separate arguments. The potentially affected contracts are those that implement signature reuse or replay protection by marking the signature itself as used rather than the signed message or a nonce included in it. A user may take a signature that has already been submitted, submit it again in a different form, and bypass this protection.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use OpenZeppelin's ECDSA.recover or ECDSA.tryRecover? (version <4.7.3)",
                                "remediation": "Use the latest stable OpenZeppelin version",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 99,
                                "category": "SOL-Basics-VI-OVI",
                                "leafId": 4,
                                "description": "Extending this contract with a custom _beforeTokenTransfer function could allow a reentrancy attack to happen. More specifically, when burning tokens, _beforeTokenTransfer is invoked before the send hook is externally called on the sender while token balances are adjusted afterwards. At the moment of the call to the sender, which can result in reentrancy, state managed by _beforeTokenTransfer may not correspond to the actual token balances or total supply.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use OpenZeppelin's ERC777? (version <3.4.0-rc.0)",
                                "remediation": "Use the latest stable OpenZeppelin version",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 84,
                                "category": "SOL-Basics-VI-OVI",
                                "leafId": 6,
                                "description": "Governor proposal creation may be blocked by frontrunning. By frontrunning the creation of a proposal, an attacker can become the proposer and gain the ability to cancel it. The attacker can do this repeatedly to try to prevent a proposal from being proposed at all. This impacts the Governor contract in v4.9.0 only, and the GovernorCompatibilityBravo contract since v4.3.0.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use OpenZeppelin's Governor or GovernorCompatibilityBravo? (version >=4.3.0 <4.9.1)",
                                "remediation": "Use the latest stable OpenZeppelin version",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 85,
                                "category": "SOL-Basics-VI-OVI",
                                "leafId": 7,
                                "description": "Transparency is broken in case of selector clash with non-decodable calldata. The TransparentUpgradeableProxy uses the ifAdmin modifier to achieve transparency. If a non-admin address calls the proxy the call should be frowarded transparently. This works well in most cases, but the forwarding of some functions can fail if there is a selector conflict and decoding issue.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use OpenZeppelin's TransparentUpgradeableProxy? (version >=3.2.0 <4.8.3)",
                                "remediation": "Use the latest stable OpenZeppelin version",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 89,
                                "category": "SOL-Basics-VI-OVI",
                                "leafId": 9,
                                "description": "Denial of Service (DoS) in the `supportsERC165InterfaceUnchecked()` function in `ERC165Checker.sol` and `ERC165CheckerUpgradeable.sol`, which can consume excessive resources when processing a large amount of data via an EIP-165 supportsInterface query.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use OpenZeppelin's ERC165Checker or ERC165CheckerUpgradeable? (version >=2.3.0 <4.7.2)",
                                "remediation": "Use the latest stable OpenZeppelin version",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 91,
                                "category": "SOL-Basics-VI-OVI",
                                "leafId": 11,
                                "description": "Checkpointing quorum was missing and past proposals that failed due to lack of quorum could pass later. It is necessary to avoid quorum changes making old, failed because of quorum, proposals suddenly successful.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use OpenZeppelin's GovernorVotesQuorumFraction? (version >=4.3.0 <4.7.2)",
                                "remediation": "Use the latest stable OpenZeppelin version",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 92,
                                "category": "SOL-Basics-VI-OVI",
                                "leafId": 12,
                                "description": "Since 0.8.0, abi.decode reverts if the bytes raw data overflow the target type. SignatureChecker.isValidSignatureNow is not expected to revert. However, an incorrect assumption about Solidity 0.8's abi.decode allows some cases to revert, given a target contract that doesn't implement EIP-1271 as expected. The contracts that may be affected are those that use SignatureChecker to check the validity of a signature and handle invalid signatures in a way other than reverting.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use OpenZeppelin's SignatureChecker? (version >=4.1.0 <4.7.1)",
                                "remediation": "Use the latest stable OpenZeppelin version",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 93,
                                "category": "SOL-Basics-VI-OVI",
                                "leafId": 13,
                                "description": "Since 0.8.0, abi.decode reverts if the bytes raw data overflow the target type. ERC165Checker.supportsInterface is designed to always successfully return a boolean, and under no circumstance revert. However, an incorrect assumption about Solidity 0.8's abi.decode allows some cases to revert, given a target contract that doesn't implement EIP-165 as expected, specifically if it returns a value other than 0 or 1. The contracts that may be affected are those that use ERC165Checker to check for support for an interface and then handle the lack of support in a way other than reverting.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use OpenZeppelin's ERC165Checker? (version >=4.0.0 <4.7.1)",
                                "remediation": "Use the latest stable OpenZeppelin version",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 94,
                                "category": "SOL-Basics-VI-OVI",
                                "leafId": 14,
                                "description": "GovernorCompatibilityBravo incorrect ABI encoding may lead to unexpected behavior",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use OpenZeppelin's GovernorCompatibilityBravo? (version >=4.3.0 <4.4.2)",
                                "remediation": "Use the latest stable OpenZeppelin version",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 95,
                                "category": "SOL-Basics-VI-OVI",
                                "leafId": 15,
                                "description": "It is possible for `initializer()`-protected functions to be executed twice, if this happens in the same transaction. For this to happen, either one call has to be a subcall the other, or both call have to be subcalls of a common initializer()-protected function. This can particularly be dangerous is the initialization is not part of the proxy construction, and reentrancy is possible by executing an external call to an untrusted address.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use OpenZeppelin's Initializable? (version >=3.2.0 <4.4.1)",
                                "remediation": "Use the latest stable OpenZeppelin version",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 96,
                                "category": "SOL-Basics-VI-OVI",
                                "leafId": 16,
                                "description": "Possible inconsistency in the value returned by totalSupply DURING a mint. If you mint a token, the receiver is a smart contract, and the receiver implements onERC1155Receive, then this receiver is called with the balance already updated, but with the totalsupply not yet updated.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use OpenZeppelin's ERC1155? (version >=4.2.0 <4.3.3)",
                                "remediation": "Use the latest stable OpenZeppelin version",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 97,
                                "category": "SOL-Basics-VI-OVI",
                                "leafId": 17,
                                "description": "Upgradeable contracts using UUPSUpgradeable may be vulnerable to an attack affecting uninitialized implementation contracts.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use OpenZeppelin's UUPSUpgradeable? (version >=4.1.0 <4.3.2)",
                                "remediation": "Use the latest stable OpenZeppelin version",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 86,
                                "category": "SOL-Basics-VI-OVI",
                                "leafId": 2,
                                "description": "GovernorCompatibilityBravo may trim proposal calldata. The proposal creation entrypoint (propose) in GovernorCompatibilityBravo allows the creation of proposals with a signatures array shorter than the calldatas array. This causes the additional elements of the latter to be ignored, and if the proposal succeeds the corresponding actions would eventually execute without any calldata. The ProposalCreated event correctly represents what will eventually execute, but the proposal parameters as queried through getActions appear to respect the original intended calldata.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use OpenZeppelin's GovernorCompatibilityBravo? (version >=4.3.0 <4.8.3)",
                                "remediation": "Use the latest stable OpenZeppelin version",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 83,
                                "category": "SOL-Basics-VI-OVI",
                                "leafId": 5,
                                "description": "When the `verifyMultiProof`, `verifyMultiProofCalldata`, `processMultiProof`, or `processMultiProofCalldata` functions are in use, it is possible to construct merkle trees that allow forging a valid multiproof for an arbitrary set of leaves.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use OpenZeppelin's `MerkleProof`? (version >=4.7.0 <4.9.2)",
                                "remediation": "Use the latest stable OpenZeppelin version",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 87,
                                "category": "SOL-Basics-VI-OVI",
                                "leafId": 8,
                                "description": "The ERC721Consecutive contract designed for minting NFTs in batches does not update balances when a batch has size 1 and consists of a single token. Subsequent transfers from the receiver of that token may overflow the balance as reported by balanceOf. The issue exclusively presents with batches of size 1.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use OpenZeppelin's ERC721Consecutive?(version >=4.8.0 <4.8.2)",
                                "remediation": "Use the latest stable OpenZeppelin version",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 90,
                                "category": "SOL-Basics-VI-OVI",
                                "leafId": 10,
                                "description": "Incorrect resource transfer between spheres via contracts using the cross-chain utilities for Arbitrum L2: `CrossChainEnabledArbitrumL2` or `LibArbitrumL2`. Calls from EOAs would be classified as cross-chain calls. The vulnerability will classify direct interactions of externally owned accounts (EOAs) as cross-chain calls, even though they are not started on L1.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use OpenZeppelin's LibArbitrumL2 or CrossChainEnabledArbitrumL2? (version >=4.6.0 <4.7.2)",
                                "remediation": "Use the latest stable OpenZeppelin version",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 98,
                                "category": "SOL-Basics-VI-OVI",
                                "leafId": 18,
                                "description": "A vulnerability in TimelockController allowed an actor with the executor role to take immediate control of the timelock, by resetting the delay to 0 and escalating privileges, thus gaining unrestricted access to assets held in the contract. Instances with the executor role set to 'open' allow anyone to use the executor role, thus leaving the timelock at risk of being taken over by an attacker.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the contract use OpenZeppelin's TimelockController? (version >=4.0.0-beta.0 <4.3.1\\\\n<3.4.2)",
                                "remediation": "Use the latest stable OpenZeppelin version",
                                "referenceList": [],
                                "childs": []
                            }
                        ]
                    }
                ]
            },
            {
                "id": 100,
                "category": "Inheritance",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 103,
                        "category": "SOL-Basics-Inheritance",
                        "leafId": 2,
                        "description": "Parent contracts often assume the inheriting contracts to implement public functions to utilize the parent's functionality. Sometimes developers miss implementing them and it makes the inheritance useless.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Were all necessary functions implemented to fulfill inheritance purpose?",
                        "remediation": "Make sure to expose relevant functions from parent contracts.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-02-pauseunpause-functionalities-not-implemented-in-many-pausable-contracts-code4rena-stader-labs-stader-labs-git",
                            "https://twitter.com/bytes032/status/1736065591536935366"
                        ],
                        "childs": []
                    },
                    {
                        "id": 101,
                        "category": "SOL-Basics-Inheritance",
                        "leafId": 3,
                        "description": "Interfaces are used by other protocols to interact with the protocol. Missing implementation will lead to unexpected cases.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Has the contract implemented an interface?",
                        "remediation": "Make sure to implement all functions specified in the interface.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 393,
                        "category": "SOL-Basics-Inheritance",
                        "leafId": 4,
                        "description": "Inheriting contracts in the wrong order can lead to unexpected behavior, e.g. storage allocation.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the inheritance order matter?",
                        "remediation": "Verify the inheritance chain is ordered from 'most base-like' to 'most derived' to prevent issues like incorrect variable initialization.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 102,
                        "category": "SOL-Basics-Inheritance",
                        "leafId": 1,
                        "description": "External/Public functions of all parent contracts will be exposed with the same visibility as long as they are not overridden.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is it necessary to limit visibility of parent contract's public functions?",
                        "remediation": "Make sure to expose only relevant functions from parent contracts.",
                        "referenceList": [],
                        "childs": []
                    }
                ]
            },
            {
                "id": 104,
                "category": "Initialization",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 105,
                        "category": "SOL-Basics-Initialization",
                        "leafId": 1,
                        "description": "Overlooking explicit initialization of state variables can lead to critical issues.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are important state variables initialized properly?",
                        "remediation": "Make sure to initialize all state variables correctly.",
                        "referenceList": [
                            "https://solodit.xyz/issues/h-01-mintersolstartinflation-can-be-bypassed-code4rena-backd-backd-tokenomics-contest-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 106,
                        "category": "SOL-Basics-Initialization",
                        "leafId": 2,
                        "description": "If the contract is supposed to be inherited by other contracts, `onlyInitializing` modifier MUST be used instead of `initializer`.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Has the contract inherited OpenZeppelin's Initializable?",
                        "remediation": "Make sure to use the correct modifier for the initializer function.",
                        "referenceList": [
                            "https://solodit.xyz/issues/h-03-wrong-implementation-of-eip712metatransaction-code4rena-rolla-rolla-contest-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 107,
                        "category": "SOL-Basics-Initialization",
                        "leafId": 3,
                        "description": "Initializer function can be front-run right after the deployment. The impact is critical if the initializer sets the access controls.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the contract have a separate initializer function other than a constructor?",
                        "remediation": "Use the factory pattern to allow only the factory to call the initializer or ensure it is not front-runnable in the deploy script.",
                        "referenceList": [
                            "https://solodit.xyz/issues/initialization-functions-can-be-front-run-trailofbits-advanced-blockchain-pdf"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 109,
                "category": "Access Control",
                "leafId": 0,
                "description": "Vulnerabilities related to access control.",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 110,
                        "category": "SOL-Basics-AC",
                        "leafId": 1,
                        "description": "This is a general check item. Having a clear understanding of all relevant actors and interactions in the protocol is critical for security.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Did you clarify all the actors and their allowed interactions in the protocol?",
                        "remediation": "List down all the actors and interactions and draw a diagram.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 111,
                        "category": "SOL-Basics-AC",
                        "leafId": 2,
                        "description": "Access controls determine who can use certain functions of a contract. If these are missing or improperly implemented, it can expose the contract to unauthorized changes or withdrawals.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are there functions lacking proper access controls?",
                        "remediation": "Implement and rigorously test access controls like `onlyOwner` or role-based permissions to ensure only authorized users can access certain functions.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 112,
                        "category": "SOL-Basics-AC",
                        "leafId": 3,
                        "description": "Whitelisting allows only a specific set of addresses to interact with the contract, offering an additional layer of security against malicious actors.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Do certain addresses require whitelisting?",
                        "remediation": "Establish a whitelisting mechanism and ensure that only trusted addresses can execute sensitive or restricted operations.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 113,
                        "category": "SOL-Basics-AC",
                        "leafId": 4,
                        "description": "Transfer of critical privileges must be done in two-step process. A two-step transfer process, usually involving a request followed by a confirmation, adds an extra layer of security against unintentional or malicious owner changes.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol allow transfer of privileges?",
                        "remediation": "Implement a two-step transfer mechanism that requires the new actor to accept the transfer, ensuring better security and intentional ownership changes.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 114,
                        "category": "SOL-Basics-AC",
                        "leafId": 5,
                        "description": "The protocol needs to work consistently and reasonably even during the transfer of privileges.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "What happens during the transfer of privileges?",
                        "remediation": "Double check how the protocol works during the transfer of privileges.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 115,
                        "category": "SOL-Basics-AC",
                        "leafId": 6,
                        "description": "If you do not override a parent contract's function explicitly, the parent's one will be exposed with its visibility and probably a wrong accessibiliy.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the contract inherit others?",
                        "remediation": "Make sure you check the accessibility to the parent's external/public functions.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 116,
                        "category": "SOL-Basics-AC",
                        "leafId": 7,
                        "description": "Use of `tx.origin` for authorization may be abused by a malicious contract forwarding calls from the legitimate user. Use `msg.sender` instead. `require( tx.origin == msg.sender)` is a useful check to ensure that the `msg.sender` is an EOA(externally owned account).",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the contract use `tx.origin` in validation?",
                        "remediation": "Make sure you know the difference of `tx.origin` and `msg.sender` and use properly.",
                        "referenceList": [
                            "https://swcregistry.io/docs/SWC-115"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 117,
                "category": "Function",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 122,
                        "category": "SOL-Basics-Function",
                        "leafId": 2,
                        "description": "Outputs of functions should be validated to prevent unexpected behavior.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are the outputs validated?",
                        "remediation": "Ensure the outputs are valid.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 123,
                        "category": "SOL-Basics-Function",
                        "leafId": 3,
                        "description": "Front-running can allow attackers to prioritize their transactions over others.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can the function be front-run?",
                        "remediation": "Make sure there is no unexpected risk even if attackers front-run.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-08-borrower-can-cause-a-dos-by-frontrunning-a-liquidation-and-repaying-as-low-as-1-wei-of-the-current-debt-code4rena-venus-protocol-venus-protocol-isolated-pools-git",
                            "https://solodit.xyz/issues/m-01-new-proposals-can-be-dosd-by-frontrunning-zachobront-none-optimismgovernormd-markdown_",
                            "https://solodit.xyz/issues/h-01-challenges-can-be-frontrun-with-de-leveraging-to-cause-lossses-for-challengers-code4rena-frankencoin-frankencoin-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 124,
                        "category": "SOL-Basics-Function",
                        "leafId": 4,
                        "description": "Misleading or outdated comments can result in misunderstood function behaviors.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are the code comments coherent with the implementation?",
                        "remediation": "Keep comments updated and ensure they accurately describe the function logic.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-08-wrong-comment-in-getfee-code4rena-yeti-finance-yeti-finance-contest-git",
                            "https://solodit.xyz/issues/m-8-wrong-change_collateral_delay-in-collateralbook-sherlock-isomorph-isomorph-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 125,
                        "category": "SOL-Basics-Function",
                        "leafId": 5,
                        "description": "Edge input values can lead to unexpected behavior.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can edge case inputs (0, max) result in unexpected behavior?",
                        "remediation": "Make sure the function works as expected for the edge values.",
                        "referenceList": [
                            "https://solodit.xyz/issues/lack-of-validation-openzeppelin-bancor-compounding-rewards-audit-markdown",
                            "https://solodit.xyz/issues/p1-m07-lack-of-input-validation-openzeppelin-eco-contracts-audit-markdown"
                        ],
                        "childs": []
                    },
                    {
                        "id": 126,
                        "category": "SOL-Basics-Function",
                        "leafId": 6,
                        "description": "Implementing a function that accepts arbitrary user input and makes low-level calls based on this data introduces a significant security risk. Low-level calls in Solidity, such as call(), are powerful and can lead to unintended contract behavior if not used cautiously. With the ability for users to supply arbitrary data, they can potentially trigger unexpected paths in the contract logic, exploit reentrancy vulnerabilities, or even interact with other contracts in a malicious manner.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the function allow arbitrary user input?",
                        "remediation": "Restrict the usage of low-level calls, especially when combined with arbitrary user input. Ensure that any data used in these calls is thoroughly validated and sanitized.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 118,
                        "category": "SOL-Basics-Function",
                        "leafId": 7,
                        "description": "Ensure the visibility modifier is appropriate for the function's use, preventing unnecessary exposure.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Should it be `external`/`public`?",
                        "remediation": "Limit function visibility to the strictest level possible (`private` or `internal`).",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 120,
                        "category": "SOL-Basics-Function",
                        "leafId": 8,
                        "description": "There are several edge cases regarding the caller checking mechanism, both for EOA and contracts.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does this function need to be called by only EOA or only contracts?",
                        "remediation": "Ensure the correct access control is implemented according to the protocol's context. (read all the references)",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-15-onlyeoaex-modifier-that-ensures-call-is-from-eoa-might-not-hold-true-in-the-future-sherlock-blueberry-blueberry-git",
                            "https://solodit.xyz/issues/m-17-addressiscontract-is-not-a-reliable-way-of-checking-if-the-input-is-an-eoa-code4rena-stakehouse-protocol-lsd-network-stakehouse-contest-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 119,
                        "category": "SOL-Basics-Function",
                        "leafId": 9,
                        "description": "Ensure that functions modifying contract state or accessing sensitive operations are access-controlled.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does this function need to be restricted for specific callers?",
                        "remediation": "Implement access control mechanisms like `onlyOwner` or custom modifiers.",
                        "referenceList": [
                            "https://solodit.xyz/issues/h-8-lack-of-access-control-for-mintrebalancer-and-burnrebalancer-sherlock-none-ussd-autonomous-secure-dollar-git",
                            "https://solodit.xyz/issues/h-02-anyone-can-change-approvaldisapproval-threshold-for-any-action-using-llamarelativequorum-strategy-code4rena-llama-llama-git",
                            "https://solodit.xyz/issues/anyone-can-take-a-loan-out-on-behalf-of-any-collateral-holder-at-any-terms-spearbit-astaria-pdf"
                        ],
                        "childs": []
                    },
                    {
                        "id": 121,
                        "category": "SOL-Basics-Function",
                        "leafId": 1,
                        "description": "Inputs to functions should be validated to prevent unexpected behavior.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are the inputs validated?",
                        "remediation": "Ensure thorough validation. E.g. min/max for numeric values, start/end for dates, ownership of positions.",
                        "referenceList": [
                            "https://solodit.xyz/issues/missing-owner-check-on-from-when-transferring-tokens-spearbit-clober-pdf",
                            "https://solodit.xyz/issues/m-13-bondbasesdasetdefaults-doesnt-validate-inputs-sherlock-bond-bond-protocol-git",
                            "https://solodit.xyz/issues/h-16-user-supplied-amm-pools-and-no-input-validation-allows-stealing-of-steth-protocol-fees-sherlock-swivel-illuminate-git"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 127,
                "category": "Proxy/Upgradable",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 128,
                        "category": "SOL-Basics-PU",
                        "leafId": 1,
                        "description": "Proxied contract can't have a constructor and it's common to move constructor logic to an external initializer function, usually called initialize",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there a constructor in the proxied contract?",
                        "remediation": "Use initializer functions for initialization of proxied contracts.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 129,
                        "category": "SOL-Basics-PU",
                        "leafId": 2,
                        "description": "Without the `initializer` modifier, there is a risk that the initialization function can be called multiple times.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the `initializer` modifier applied to the `initialization()` function?",
                        "remediation": "Always use the `initializer` modifier for initialization functions in proxied contracts and ensure they're called once during deployment.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 130,
                        "category": "SOL-Basics-PU",
                        "leafId": 3,
                        "description": "Upgradable contracts must use the upgradable versions of parent initializer functions. (e.g. Pausable vs PausableUpgradable)",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the upgradable version used for initialization?",
                        "remediation": "Use upgradable versions of parent initializer functions.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 131,
                        "category": "SOL-Basics-PU",
                        "leafId": 4,
                        "description": "Inadequate security on the `authorizeUpgrade()` function can allow unauthorized upgrades.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the `authorizeUpgrade()` function properly secured in a UUPS setup?",
                        "remediation": "Ensure proper access controls and checks are in place for the `authorizeUpgrade()` function.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 133,
                        "category": "SOL-Basics-PU",
                        "leafId": 5,
                        "description": "An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation contract, which may impact the proxy.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the contract initialized?",
                        "remediation": "To prevent the implementation contract from being used, invoke the `_disableInitializers` function in the constructor to automatically lock it when it is deployed.",
                        "referenceList": [
                            "https://docs.openzeppelin.com/contracts/4.x/api/proxy#Initializable"
                        ],
                        "childs": []
                    },
                    {
                        "id": 134,
                        "category": "SOL-Basics-PU",
                        "leafId": 6,
                        "description": "Using `selfdestruct` and `delegatecall` in implementation contracts can introduce vulnerabilities and unexpected behavior in a proxy setup.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are `selfdestruct` and `delegatecall` used within the implementation contracts?",
                        "remediation": "Avoid using `selfdestruct` and `delegatecall` in implementation contracts to ensure contract stability and security.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 135,
                        "category": "SOL-Basics-PU",
                        "leafId": 7,
                        "description": "Immutable variables are stored in the bytecode, not in the proxy storage. So using immutable variable is not recommended in proxy setup. If used, make sure all immutables stay consistent across implementations during upgrades.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are values in immutable variables preserved between upgrades?",
                        "remediation": "Avoid using immutable variables in upgradable contracts.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 132,
                        "category": "SOL-Basics-PU",
                        "leafId": 9,
                        "description": "Storage collisions can occur when storage layouts between contract versions conflict, leading to data corruption and unpredictable behavior.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Could an upgrade of the contract result in storage collision?",
                        "remediation": "Maintain a consistent storage layout between upgrades, and when using inheritance, set storage gaps to avoid potential collisions.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 136,
                        "category": "SOL-Basics-PU",
                        "leafId": 10,
                        "description": "Changing the order or type of storage variables between upgrades can lead to storage collisions.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are the order and types of storage variables consistent between upgrades?",
                        "remediation": "Maintain a consistent order and type for storage variables across contract versions to avoid storage collisions.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 137,
                        "category": "SOL-Basics-PU",
                        "leafId": 8,
                        "description": "Sometimes developers overlook and use an incorrect branch of OZ library, e.g. use Ownable instead of OwnableUpgradeable.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Has the contract inherited the correct branch of OpenZeppelin library?",
                        "remediation": "Make sure inherit the correct branch of OZ library according to the contract's upgradeability design.",
                        "referenceList": [
                            "https://solodit.xyz/issues/h-01-usage-of-an-incorrect-version-of-ownbale-library-can-potentially-malfunction-all-onlyowner-functions-code4rena-covalent-covalent-contest-git"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 138,
                "category": "Array / Loop",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 387,
                        "category": "SOL-Basics-AL",
                        "leafId": 1,
                        "description": "Sometimes the first and last cycles have a different logic from others and there can be problems.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "What happens on the first and the last cycle of the iteration?",
                        "remediation": "Ensure the logic is correct for the first and the last cycles.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 395,
                        "category": "SOL-Basics-AL",
                        "leafId": 5,
                        "description": "If an array is supposed to be updated (removal in the middle), the indexes will change.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does any function get an index of an array as an argument?",
                        "remediation": "Do not use an index of an array that is supposed to be updated as a parameter of a function.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 397,
                        "category": "SOL-Basics-AL",
                        "leafId": 7,
                        "description": "In most cases, an array (especially an input array by users) is supposed to be unique.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is it fine to have duplicate items in the array?",
                        "remediation": "Add a validation to check the array is unique.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 399,
                        "category": "SOL-Basics-AL",
                        "leafId": 9,
                        "description": "Due to the block gas limit, there is a clear limitation in the amount of operation that can be handled in a transaction.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there possibility of iteration of a huge array?",
                        "remediation": "Ensure the number of iterations is properly bounded.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 400,
                        "category": "SOL-Basics-AL",
                        "leafId": 10,
                        "description": "Loops that contain external calls or are dependent on user-controlled input can be exploited to halt the contract's functions. (e.g. sending ETH to multiple users)",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there a potential for a Denial-of-Service (DoS) attack in the loop?",
                        "remediation": "Ensure a failure of a single iteration does not revert the whole operation.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 403,
                        "category": "SOL-Basics-AL",
                        "leafId": 13,
                        "description": "Sometimes developers overlook the edge cases that can happened due to the break or continue in the middle of the loop.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there a break or continue inside a loop?",
                        "remediation": "Make sure the break or continue inside a loop does not lead to unexpected behaviors.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 394,
                        "category": "SOL-Basics-AL",
                        "leafId": 4,
                        "description": "`delete` does not rearrange the array but just resets the element.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "How does the protocol remove an item from an array?",
                        "remediation": "Copy the last element to the index of the element to be removed and decrease the length of an array.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 396,
                        "category": "SOL-Basics-AL",
                        "leafId": 6,
                        "description": "Direct calculation against a sum may yield different results than the sum of individual calculations, leading to precision issues.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the summing of variables done accurately compared to separate calculations?",
                        "remediation": "Ensure that summation logic is thoroughly tested and verified, especially when dealing with financial calculations to maintain accuracy.",
                        "referenceList": [
                            "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/174"
                        ],
                        "childs": []
                    },
                    {
                        "id": 398,
                        "category": "SOL-Basics-AL",
                        "leafId": 8,
                        "description": "The first and the last iteration in loops can sometimes have edge cases that differ from other iterations, possibly leading to vulnerabilities.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there any issue with the first and the last iteration?",
                        "remediation": "Always test the initial and the last iteration separately and ensure consistent behavior throughout all iterations.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 401,
                        "category": "SOL-Basics-AL",
                        "leafId": 11,
                        "description": "`msg.value` is consistent for the whole transaction. If it is used in the for loop, it is likely there is a mistake in accounting.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is `msg.value` used within a loop?",
                        "remediation": "Avoid using `msg.value` inside loops. Refer to multi-call vulnerability.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 402,
                        "category": "SOL-Basics-AL",
                        "leafId": 12,
                        "description": "If there is a mechanism to transfer funds out based on some kind of shares, it is likely that there is a problem of 'dust' funds not handled correctly.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there a loop to handle batch fund transfer?",
                        "remediation": "Make sure the last transfer handles all residual.",
                        "referenceList": [],
                        "childs": []
                    }
                ]
            },
            {
                "id": 139,
                "category": "Map",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 140,
                        "category": "SOL-Basics-Map",
                        "leafId": 1,
                        "description": "If a variable of nested structure is deleted, only the top-level fields are reset by default values (zero) and the nested level fields are not reset.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there need to delete the existing item from a map?",
                        "remediation": "Always ensure that inner fields are deleted before the outer fields of the structure.",
                        "referenceList": [],
                        "childs": []
                    }
                ]
            },
            {
                "id": 141,
                "category": "Math",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 142,
                        "category": "SOL-Basics-Math",
                        "leafId": 1,
                        "description": "Ensure that the logic behind any mathematical operation is correctly implemented.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the mathematical calculation accurate?",
                        "remediation": "Verify calculations against established mathematical rules in the document or the comments.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 143,
                        "category": "SOL-Basics-Math",
                        "leafId": 2,
                        "description": "Loss of precision can lead to significant errors over time or frequent calculations.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there any loss of precision in time calculations?",
                        "remediation": "Use appropriate data types and ensure rounding methods are correctly applied.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 144,
                        "category": "SOL-Basics-Math",
                        "leafId": 3,
                        "description": "Operations with certain expressions might lead to unintended data type conversions.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are you aware that expressions like `1 day` are cast to `uint24`, potentially causing overflows?",
                        "remediation": "Always be explicit with data types and avoid relying on implicit type conversions.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 145,
                        "category": "SOL-Basics-Math",
                        "leafId": 4,
                        "description": "Multiplying before division is generally better to keep the precision.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there any case where dividing is done before multiplication?",
                        "remediation": "To avoid loss of precision, always multiply first and then divide.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 146,
                        "category": "SOL-Basics-Math",
                        "leafId": 5,
                        "description": "Rounding direction often matters when the accounting relies on user's shares.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the rounding direction matter?",
                        "remediation": "Use the proper rounding direction in favor of the protocol",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 147,
                        "category": "SOL-Basics-Math",
                        "leafId": 6,
                        "description": "Division by zero will revert the transaction.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there a possibility of division by zero?",
                        "remediation": "Always check denominators before division.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 148,
                        "category": "SOL-Basics-Math",
                        "leafId": 7,
                        "description": "Variables can sometimes exceed their bounds, causing reverts.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Even in versions like `>0.8.0`, have you ensured variables won't underflow or overflow leading to reverts?",
                        "remediation": "Use checks to prevent variable underflows and overflows.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 149,
                        "category": "SOL-Basics-Math",
                        "leafId": 8,
                        "description": "Unsigned integers cannot hold negative values.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are you aware that assigning a negative value to an unsigned integer causes a revert?",
                        "remediation": "Always ensure that only non-negative values are assigned to unsigned integers.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 150,
                        "category": "SOL-Basics-Math",
                        "leafId": 9,
                        "description": "Arithmetics do not overflow inside the `unchecked{}` block.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Have you properly reviewed all usages of `unchecked{}`?",
                        "remediation": "Use `unchecked{}` only when it is strictly guaranteed that no overflow/underflow happens.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 151,
                        "category": "SOL-Basics-Math",
                        "leafId": 10,
                        "description": "Usage of incorrect inequality can cause unexpected behavior for the edge values.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "In comparisons using < or >, should you instead be using  or ?",
                        "remediation": "Review the logic and ensure the appropriate comparison operators are used.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 152,
                        "category": "SOL-Basics-Math",
                        "leafId": 11,
                        "description": "Inline assembly can behave differently than high-level language constructs. (division by zero, overflow/underflow do not revert!)",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Have you taken into consideration mathematical operations in inline assembly?",
                        "remediation": "Ensure mathematical operations in inline assembly are properly tested and verified.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 153,
                        "category": "SOL-Basics-Math",
                        "leafId": 12,
                        "description": "If the calculation includes numerous terms, you need to confirm all edge cases where each term has the possible min/max values.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "What happens for the minimum/maximum values included in the calculation?",
                        "remediation": "Ensure the edge cases do not lead to unexpected outcome.",
                        "referenceList": [],
                        "childs": []
                    }
                ]
            },
            {
                "id": 154,
                "category": "Payment",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 435,
                        "category": "SOL-Basics-Payment",
                        "leafId": 7,
                        "description": "If a `payable` function does not transfer all ETH passed in `msg.value` and the contract does not have a withdraw method, ETH will be locked in the contract",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is it possible for native ETH to be locked in the contract?",
                        "remediation": "Make sure either no ETH remains in the contract at the end of `payable` functions or make sure there is a `withdraw` function.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-09-bathbuddy-locks-up-ether-it-receives-code4rena-rubicon-rubicon-contest-git",
                            "https://solodit.xyz/issues/m-22-eth-sent-when-calling-executeassmartwallet-function-can-be-lost-code4rena-stakehouse-protocol-lsd-network-stakehouse-contest-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 156,
                        "category": "SOL-Basics-Payment",
                        "leafId": 1,
                        "description": "There are cases where a receiver contract can deny the transaction. For example, a malicious receiver can have a fallback to revert. If a caller tried to send funds using `transfer` or `send`, the whole transaction will revert. (Meanwhile, `call()` does not revert but returns a boolean)",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is it possible for the receiver to revert?",
                        "remediation": "Make sure that the receiver can not deny the payment or add a backup handler with a try-catch.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 157,
                        "category": "SOL-Basics-Payment",
                        "leafId": 2,
                        "description": "For ETH deposits, `msg.value` must be checked if it is not less than the amount specified.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the function gets the payment amount as a parameter?",
                        "remediation": "Require `msg.value==amount`.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 158,
                        "category": "SOL-Basics-Payment",
                        "leafId": 3,
                        "description": "Certain actions like self-destruct, deterministic address feeding, and coinbase transactions can be used to force-feed contracts.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are there vulnerabilities related to force-feeding?",
                        "remediation": "Ensure the contract behaves as expected when receiving unexpected funds.",
                        "referenceList": [
                            "https://scsfg.io/hackers/unexpected-ether/"
                        ],
                        "childs": []
                    },
                    {
                        "id": 159,
                        "category": "SOL-Basics-Payment",
                        "leafId": 5,
                        "description": "The best practice in withdrawal process is to implement pull-based approach. Track the accounting and let users pull the payments instead of sending funds proactively.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "How is the withdrawal handled?",
                        "remediation": "Implement pull-based approach in withdrawals.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 160,
                        "category": "SOL-Basics-Payment",
                        "leafId": 4,
                        "description": "Dust deposit/withdrawal often can lead to various vulnerabilities, e.g. rounding issue in accounting or Denial-Of-Service.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "What is the minimum deposit/withdrawal amount?",
                        "remediation": "Add a threshold for the deposit/withdrawal amount.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 155,
                        "category": "SOL-Basics-Payment",
                        "leafId": 6,
                        "description": "The transfer() and send() functions forward a fixed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guard against reentrancy attacks. However, the gas cost of EVM instructions may change significantly during hard forks which may break already deployed contract systems that make fixed assumptions about gas costs. For example. EIP 1884 broke several existing smart contracts due to a cost increase of the SLOAD instruction.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is `transfer()` or `send()` used for sending ETH?",
                        "remediation": "Use `call()` to prevent potential gas issues.",
                        "referenceList": [
                            "https://solodit.xyz/issues/use-call-instead-of-transfer-cyfrin-none-woosh-deposit-vault-markdown",
                            "https://solodit.xyz/issues/m-5-call-should-be-used-instead-of-transfer-on-an-address-payable-sherlock-dodo-dodo-git",
                            "https://solodit.xyz/issues/m-10-addresscallvaluex-should-be-used-instead-of-payabletransfer-code4rena-debt-dao-debt-dao-contest-git"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 457,
                "category": "Block Reorganization",
                "leafId": 0,
                "description": "A chain reorganization, or reorg, happens when validators disagree on the most accurate version of the blockchain. Reorgs occurs when multiple blocks happen to be produced at the same time, if there is a bug, or due to a malicious attack.",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 458,
                        "category": "SOL-Basics-BR",
                        "leafId": 1,
                        "description": "Contracts created with the CREATE opcode will be eliminated if a block reorg happens.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol implement a factory pattern using the CREATE opcode?",
                        "remediation": "Use CREATE2 instead of CREATE.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-08-factorycreate-is-vulnerable-to-reorg-attacks-code4rena-abracadabra-money-abracadabra-money-git",
                            "https://solodit.xyz/issues/m-02-reorg-attack-on-users-vault-deployment-and-deposit-may-lead-to-theft-of-funds-code4rena-amphora-protocol-amphora-protocol-git",
                            "https://solodit.xyz/issues/m-4-loss-of-bond-amounts-on-re-org-attacks-sherlock-optimism-fault-proofs-git",
                            "https://solodit.xyz/issues/m-01-questfactory-is-suspicious-of-the-reorg-attack-code4rena-rabbithole-rabbithole-quest-protocol-contest-git",
                            "https://solodit.xyz/issues/m-14-re-org-attack-in-factory-code4rena-frankencoin-frankencoin-git"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 108,
                "category": "Type",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 391,
                        "category": "SOL-Basics-Type",
                        "leafId": 1,
                        "description": "Explicit type casting does not revert on overflow/underflow.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there a forced type casting?",
                        "remediation": "Avoid a forced type casting as much as possible and ensure values are in the range of type limit.",
                        "referenceList": [
                            "https://solodit.xyz/issues/risk-of-token-theft-due-to-unchecked-type-conversion-trailofbits-none-primitive-hyper-pdf"
                        ],
                        "childs": []
                    },
                    {
                        "id": 392,
                        "category": "SOL-Basics-Type",
                        "leafId": 2,
                        "description": "The time units are of `uint8` type and this can lead to unintended overflow.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol use time units like `days`?",
                        "remediation": "Double check the calculations including time units and ensure there is no overflow for reasonable values.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-05-expiration-calculation-overflows-if-call-option-duration-195-days-code4rena-cally-cally-contest-git"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 161,
                "category": "Event",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 389,
                        "category": "SOL-Basics-Event",
                        "leafId": 1,
                        "description": "Emitting events properly is important especially if the change is critical.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol emit events on important state changes?",
                        "remediation": "Ensure to emit events in all important functions.",
                        "referenceList": [],
                        "childs": []
                    }
                ]
            }
        ]
    },
    {
        "id": 278,
        "category": "Centralization Risk",
        "leafId": 0,
        "description": "",
        "isLeaf": false,
        "hasNoLeaf": false,
        "question": "",
        "remediation": "",
        "referenceList": [],
        "childs": [
            {
                "id": 280,
                "category": "SOL-CR",
                "leafId": 1,
                "description": "Users must be allowed to manage their existing positions in all protocol status. For example, users must be able to repay the debt even when the protocol is paused or the protocol should not accrue debts when it is paused.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "What happens to the user accounting in special conditions?",
                "remediation": "Ensure user positions are protected in special/emergent protocol situations.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 279,
                "category": "SOL-CR",
                "leafId": 2,
                "description": "Some functionalities must work even when the whole protocol is paused. For example, users must be able to withdraw (or repay) assets even while the protocol is paused.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is there a pause mechanism?",
                "remediation": "Review the pause mechanism thoroughly to ensure that it only affects intended functions and can't be abused by a malicious operator.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 282,
                "category": "SOL-CR",
                "leafId": 3,
                "description": "Some protocols are written to allow admin pull any amount of assets from the pool. This is a red flag and MUST be disallowed. The best practice is to track the protocol fee and only allow access to that amount.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is there a functionality for the admin to withdraw from the protocol?",
                "remediation": "Ensure the admin can not steal user funds. Track the protocol earning separately.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 283,
                "category": "SOL-CR",
                "leafId": 4,
                "description": "Changes in the critical protocol properties MUST go through a cooling period to allow users react on the changes.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Can the admin change critical protocol property immediately?",
                "remediation": "Implement a timelock for the critical property changes and emit proper events.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 284,
                "category": "SOL-CR",
                "leafId": 5,
                "description": "Events are often used to monitor the protocol status. Without emission of events, users might be affected due to ignorance of the changes.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is there any admin setter function missing events?",
                "remediation": "Emit proper events on critical configuration changes.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 285,
                "category": "SOL-CR",
                "leafId": 6,
                "description": "Critical privileges MUST be transferred via a two-step process and the protocol MUST behave as expected before/during/after transfer.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "How is the ownership/privilege transferred??",
                "remediation": "Use two-step process for transferring critical privileges and ensure the protocol works properly before/during/after the transfer.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 281,
                "category": "SOL-CR",
                "leafId": 7,
                "description": "The validation on the protocol configuration values is often overlooked assuming the admin is trusted. But it is always recommended clarifying the range of each configuration value and validate in setter functions. (e.g. protocol fee should be limited)",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is there a proper validation in privileged setter functions?",
                "remediation": "Ensure the protocol level properties are properly validated in the documented range.",
                "referenceList": [],
                "childs": []
            }
        ]
    },
    {
        "id": 203,
        "category": "Defi",
        "leafId": 0,
        "description": "",
        "isLeaf": false,
        "hasNoLeaf": false,
        "question": "",
        "remediation": "",
        "referenceList": [],
        "childs": [
            {
                "id": 446,
                "category": "Liquid Staking Derivatives",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 448,
                        "category": "SOL-Defi-LSD",
                        "leafId": 2,
                        "description": "Liquid staking protocols typically have their own liquid ERC20 token that accrues value against ETH as the protocol receives staking rewards; in the normal course of operations the exchange rate should continually be increasing as the protocol accrues rewards such that the protocol's ERC20 token can be exchanged for increasing amounts of ETH. If the protocol allows instant withdrawals, an attacker can perform a risk-free sandwich attack to drain ETH from the protocol by 1) front-running the exchange rate txn to deposit a large amount of ETH, 2) back-running to withdraw at the increased rate.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can the exchange rate repricing update be sandwich attacked to drain ETH from the protocol?",
                        "remediation": "Don't allow instant withdrawals but use a withdrawal queue and run the repricing transaction through flashbots.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 449,
                        "category": "SOL-Defi-LSD",
                        "leafId": 3,
                        "description": "Re-entrancy vulnerabilties can often exist in the reward or withdrawal code of LSD protocols.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can re-entrancy when ETH is sent during rewards/withdrawals or when NFTs are minted via `_safeMint` (to represent pending withdrawals) be used to drain the protocol's ETH?",
                        "remediation": "Always follow the Checks-Effects-Interactions pattern; sending ETH or minting NFTs via `_safeMint` should always happen after storage updates.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 450,
                        "category": "SOL-Defi-LSD",
                        "leafId": 4,
                        "description": "If an arbitrary exchange rate can be set when processing queued withdrawals this creates a subtle rug-pull vector of user withdrawals.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can an arbitrary exchange rate be set when processing queued withdrawals?",
                        "remediation": "When withdrawals are processed the current exchange rate should be retrieved in the same way as when withdrawals are created.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 451,
                        "category": "SOL-Defi-LSD",
                        "leafId": 5,
                        "description": "LSD protocols often implement pausing of different functionality. Auditors should check if there are any gaps where for example one function is missing a pause check that other related functions contain.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can paused states be bypassed to perform restricted actions even when they should be paused?",
                        "remediation": "All related functions should contain the same related pause checks.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 452,
                        "category": "SOL-Defi-LSD",
                        "leafId": 6,
                        "description": "To reduce the gas cost of reading from storage, protocols may use multiple inter-related data structures to store complex information like operator and validator information. Auditors should examine whether functions which update these inter-related data structures can be used to corrupt them by over-writing records which contain indexes into to another storage location.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can inter-related storage be corrupted, especially storage related to operators and validators?",
                        "remediation": "Protocols can use invariant fuzz testing with invariants which validate that relationships between inter-related data structures can't be broken by functions which update them.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 447,
                        "category": "SOL-Defi-LSD",
                        "leafId": 1,
                        "description": "A malicious Ethereum validator can betray a liquid staking protocol by front-running to first call `DepositContract::deposit` sending 1 ETH and passing their own withdrawal credentials; after the protocol's subsequent call succeeds the withdrawal credentials are not overwritten since only the \"initial deposit\" sets the withdrawals credentials while the second deposit is treated as a \"top-up deposit\".  The malicious validator now controls 33 ether with 32 ether belonging to the protocol's users and has set their own withdrawal credentials instead of the protocol's withdrawal credentials.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can a malicious validator front-run setting withdrawal credentials?",
                        "remediation": "The function which calls `DepositContract::deposit` should take as input `DepositContract.get_deposit_root` then check that the input deposit root matches the current one. This works as the current deposit root changes with every deposit.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 453,
                        "category": "SOL-Defi-LSD",
                        "leafId": 7,
                        "description": "LSD protocols may need to iterate over the entire set of operators or validators which can become exorbitantly expensive or lead to out of gas if the operator or validator set becomes large. In permissionless systems where anyone can create operators or validators this creates a denial of service attack vector.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol iterate over the entire set of operators or validators?",
                        "remediation": "Refactor to avoid needing to iterate over the entire operator/validator set. Alternatively only use a small and trusted set of operators/validators.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 454,
                        "category": "SOL-Defi-LSD",
                        "leafId": 8,
                        "description": "LSD protocols may use an external Proof of Reserves Oracle to fetch off-chain data for their current ETH reserves. If the protocol doesn't check how long ago the data was last updated it can process stale data as if it were fresh.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "If using a Proof Of Reserves Oracle, does the protocol check for stale data?",
                        "remediation": "Check the time data was last updated against the Oracle's heartbeat and revert if the data is too old.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 455,
                        "category": "SOL-Defi-LSD",
                        "leafId": 9,
                        "description": "Mathematical calculations have to be performed in LSD protocol deposit, withdrawal and reward functions. Auditors should check for precision loss issues such as division before multiplication, rounding down to zero etc.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does unnecessary precision loss occur in deposit, withdrawal or reward calculations?",
                        "remediation": "Don't perform division before multiplication, be aware of rounding down to zero, rounding direction, unsafe casting etc.",
                        "referenceList": [],
                        "childs": []
                    }
                ]
            },
            {
                "id": 204,
                "category": "General",
                "leafId": 0,
                "description": "Common vulnerabilities of general Defi protocols",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 207,
                        "category": "SOL-Defi-General",
                        "leafId": 1,
                        "description": "Not all ERC20 tokens use 18 decimals. Overlooking this can lead to computation errors.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can the protocol handle ERC20 tokens with decimals other than 18?",
                        "remediation": "Always check and adjust for the decimal count of the ERC20 tokens being handled.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 205,
                        "category": "SOL-Defi-General",
                        "leafId": 3,
                        "description": "Direct transfers of assets without using the protocol's logic can lead to various problems in accounting especially if the accounting relies on `balanceOf` (or `address.balance`).",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Could direct transfers of funds introduce vulnerabilities?",
                        "remediation": "Implement the internal accounting so that it is not be affected by direct transfers.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 206,
                        "category": "SOL-Defi-General",
                        "leafId": 4,
                        "description": "The first deposit can set certain parameters or conditions that subsequent deposits rely on.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Could the initial deposit introduce any issues?",
                        "remediation": "Test and ensure that the first deposit initializes and sets all necessary parameters correctly.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 211,
                        "category": "SOL-Defi-General",
                        "leafId": 5,
                        "description": "The target tokens can be depegged.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are the protocol token pegged to any other asset?",
                        "remediation": "Ensure the protocol behave as expected during the depeg.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 213,
                        "category": "SOL-Defi-General",
                        "leafId": 6,
                        "description": "Setting high allowances can make funds vulnerable to abuse; protocols sometimes set max to prevent this risk.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol revert on maximum approval to prevent over-allowance?",
                        "remediation": "Consider implementing a revert on approval functions when an unnecessarily high allowance is set.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-3-universalapprovemax-will-not-work-for-some-tokens-that-dont-support-approve-typeuint256max-amount-sherlock-dodo-dodo-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 208,
                        "category": "SOL-Defi-General",
                        "leafId": 7,
                        "description": "Leaving residual amounts can lead to discrepancies in accounting or locked funds.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "What would happen if only 1 wei remains in the pool?",
                        "remediation": "Implement logic to handle minimal residual amounts in the pool.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 209,
                        "category": "SOL-Defi-General",
                        "leafId": 8,
                        "description": "Protocols often provide various benefits to the depositors based on the deposit amount. This can lead to flashloan-deposit-harvest-withdraw attack cycle.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is it possible to withdraw in the same transaction of deposit?",
                        "remediation": "Ensure the withdrawal is protected for some blocks after deposit.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 210,
                        "category": "SOL-Defi-General",
                        "leafId": 9,
                        "description": "Not all ERC20 tokens are compliant to the ERC20 standard and there are several weird ERC20 tokens (e.g. Fee-On-Transfer tokens, rebasing tokens, tokens with blacklisting).",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol aim to support ALL kinds of ERC20 tokens?",
                        "remediation": "Clarify what kind of tokens are supported and whitelist the ERC20 tokens that the protocol would accept.",
                        "referenceList": [
                            "https://github.com/d-xo/weird-erc20"
                        ],
                        "childs": []
                    },
                    {
                        "id": 212,
                        "category": "SOL-Defi-General",
                        "leafId": 2,
                        "description": "Some protocols or platforms may provide additional rewards for staked or deposited assets. If these rewards are not properly accounted for or managed, it could lead to discrepancies in the user's expected vs actual returns.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are there unexpected rewards accruing for user deposited assets?",
                        "remediation": "The protocol should have mechanisms in place to track all potential rewards for user deposited assets. Users should be provided with clear interfaces or methods to claim any unexpected rewards to ensure fairness and transparency.",
                        "referenceList": [],
                        "childs": []
                    }
                ]
            },
            {
                "id": 214,
                "category": "Oracle",
                "leafId": 0,
                "description": "Price oracle related vulnerabilities",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 215,
                        "category": "SOL-Defi-Oracle",
                        "leafId": 1,
                        "description": "Usage of deprecated Chainlink functions like latestAnswer() might return stale or incorrect data, affecting the integrity of smart contracts.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the Oracle using deprecated Chainlink functions?",
                        "remediation": "Replace deprecated functions with the current recommended methods to ensure accurate data retrieval from oracles.",
                        "referenceList": [
                            "https://github.com/code-423n4/2022-04-backd-findings/issues/17"
                        ],
                        "childs": []
                    },
                    {
                        "id": 216,
                        "category": "SOL-Defi-Oracle",
                        "leafId": 2,
                        "description": "Price feed might return zero and this must be handled as invalid.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the returned price validated to be non-zero?",
                        "remediation": "Ensure the returned price is not zero.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 217,
                        "category": "SOL-Defi-Oracle",
                        "leafId": 3,
                        "description": "Price feeds might not be supported in the future. To ensure accurate price usage, it's vital to regularly check the last update timestamp against a predefined delay.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the price update time validated?",
                        "remediation": "Implement a mechanism to check the heartbeat of the price feed and compare it against a predefined maximum delay (`MAX_DELAY`). Adjust the `MAX_DELAY` variable based on the observed heartbeat.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 218,
                        "category": "SOL-Defi-Oracle",
                        "leafId": 4,
                        "description": "The rollup sequencer can become offline, which can lead to potential vulnerabilities due to stale price.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there a validation to check if the rollup sequencer is running?",
                        "remediation": "Utilize the sequencer uptime feed to confirm the sequencers are up.",
                        "referenceList": [
                            "https://docs.chain.link/data-feeds/l2-sequencer-feeds"
                        ],
                        "childs": []
                    },
                    {
                        "id": 219,
                        "category": "SOL-Defi-Oracle",
                        "leafId": 5,
                        "description": "An inadequately set TWAP (Time-Weighted Average Price) period could be exploited to manipulate prices.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the Oracle's TWAP period appropriately set?",
                        "remediation": "Adjust the TWAP period to a duration that mitigates the risk of manipulation while providing timely price updates.",
                        "referenceList": [
                            "https://github.com/code-423n4/2022-06-canto-v2-findings/issues/124"
                        ],
                        "childs": []
                    },
                    {
                        "id": 220,
                        "category": "SOL-Defi-Oracle",
                        "leafId": 6,
                        "description": "In multi-chain deployments, it's crucial to ensure the desired price feed pair is available and consistent across all chains.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the desired price feed pair supported across all deployed chains?",
                        "remediation": "Review the supported price feed pairs on all chains and ensure they are consistent.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 221,
                        "category": "SOL-Defi-Oracle",
                        "leafId": 7,
                        "description": "A price feed heartbeat that's too slow might not be suitable for some use cases.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the heartbeat of the price feed suitable for the use case?",
                        "remediation": "Assess the requirements of the use case and ensure the price feed heartbeat aligns with them.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 222,
                        "category": "SOL-Defi-Oracle",
                        "leafId": 8,
                        "description": "Different price feeds might have varying decimal precisions, which can lead to inaccuracies.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are there any inconsistencies with decimal precision when using different price feeds?",
                        "remediation": "Ensure that the contract handles potential variations in decimal precision across different price feeds.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 223,
                        "category": "SOL-Defi-Oracle",
                        "leafId": 9,
                        "description": "Hard-coded price feed addresses can be problematic, especially if they become deprecated or if they're not accurate in the first place.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the price feed address hard-coded?",
                        "remediation": "Review and verify the hardcoded price feed addresses. Consider mechanisms to update the address if required in the future.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 224,
                        "category": "SOL-Defi-Oracle",
                        "leafId": 10,
                        "description": "Oracle price updates can be front-run and cause various problems.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "What happens if oracle price updates are front-run?",
                        "remediation": "Ensure the protocol is not affected in the case where oracle price updates are front-run.",
                        "referenceList": [
                            "https://blog.angle.money/angle-research-series-part-1-oracles-and-front-running-d75184abc67"
                        ],
                        "childs": []
                    },
                    {
                        "id": 225,
                        "category": "SOL-Defi-Oracle",
                        "leafId": 11,
                        "description": "Unanticipated oracle reverts can lead to Denial-Of-Service.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "How does the system handle potential oracle reverts?",
                        "remediation": "Implement try/catch blocks around oracle calls and have alternative strategies ready.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 226,
                        "category": "SOL-Defi-Oracle",
                        "leafId": 12,
                        "description": "Using an ETH price feed for stETH or a BTC price feed for WBTC can introduce risks associated with the underlying assets deviating from their pegs.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are the price feeds appropriate for the underlying assets?",
                        "remediation": "Ensure that the price feeds accurately represent the underlying assets to address potential depeg risks.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 228,
                        "category": "SOL-Defi-Oracle",
                        "leafId": 13,
                        "description": "Reliance on AMM spot prices as oracles can be manipulated via flashloan.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the contract vulnerable to oracle manipulation, especially using spot prices from AMMs?",
                        "remediation": "Choose reliable and tamper-resistant oracle sources. Avoid using spot prices from AMMs directly without additional checks.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 227,
                        "category": "SOL-Defi-Oracle",
                        "leafId": 14,
                        "description": "During flash crashes, oracles might return inaccurate prices.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "How does the system address potential inaccuracies during flash crashes?",
                        "remediation": "Implement checks to ensure that the price returned by the oracle lies within an expected range to guard against potential flash crash vulnerabilities.",
                        "referenceList": [],
                        "childs": []
                    }
                ]
            },
            {
                "id": 229,
                "category": "AMM/Swap",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 436,
                        "category": "SOL-Defi-AS",
                        "leafId": 13,
                        "description": "ON-chain slippage calculation can be manipulated.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the slippage calculated on-chain?",
                        "remediation": "Allow users to specify the slippage parameter in the actual asset amount which was calculated off-chain.",
                        "referenceList": [
                            "https://dacian.me/defi-slippage-attacks#heading-on-chain-slippage-calculation-can-be-manipulated"
                        ],
                        "childs": []
                    },
                    {
                        "id": 230,
                        "category": "SOL-Defi-AS",
                        "leafId": 1,
                        "description": "Using hardcoded slippage can lead to poor trades and freezing user funds during times of high volatility.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is hardcoded slippage used?",
                        "remediation": "Allow users to specify the slippage parameter in the actual asset amount which was calculated off-chain.",
                        "referenceList": [
                            "https://dacian.me/defi-slippage-attacks#heading-on-chain-slippage-calculation-can-be-manipulated"
                        ],
                        "childs": []
                    },
                    {
                        "id": 437,
                        "category": "SOL-Defi-AS",
                        "leafId": 14,
                        "description": "Enforcing slippage parameters for intermediate swaps but not the final step can result in users receiving less tokens than their specified minimum",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the slippage parameter enforced at the last step before transferring funds to users?",
                        "remediation": "Enforce slippage parameter as the last step before transferring funds to users",
                        "referenceList": [
                            "https://dacian.me/defi-slippage-attacks#heading-mintokensout-for-intermediate-not-final-amount"
                        ],
                        "childs": []
                    },
                    {
                        "id": 231,
                        "category": "SOL-Defi-AS",
                        "leafId": 2,
                        "description": "Without deadline protection, user transactions are vulnerable to sandwich attacks.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there a deadline protection?",
                        "remediation": "Allow a user specify the deadline of the swap.",
                        "referenceList": [
                            "https://defihacklabs.substack.com/p/solidity-security-lesson-6-defi-slippage?utm_source=profile&utm_medium=reader2"
                        ],
                        "childs": []
                    },
                    {
                        "id": 232,
                        "category": "SOL-Defi-AS",
                        "leafId": 3,
                        "description": "Protocols may face risks if reserves are not validated and can be lent out, affecting the system's solvency.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there a validation check for protocol reserves?",
                        "remediation": "Ensure reserve validation logic is in place to safeguard the protocol's liquidity and overall health.",
                        "referenceList": [
                            "https://github.com/sherlock-audit/2022-08-sentiment-judging/blob/main/122-M/1-report.md"
                        ],
                        "childs": []
                    },
                    {
                        "id": 233,
                        "category": "SOL-Defi-AS",
                        "leafId": 4,
                        "description": "Using forked code, especially from known projects like Uniswap, can introduce known vulnerabilities if not updated or audited properly.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the AMM utilize forked code?",
                        "remediation": "Review the differences. Utilize tools such as contract-diff.xyz to compare and identify the origin of code snippets.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 234,
                        "category": "SOL-Defi-AS",
                        "leafId": 5,
                        "description": "Rounding issues in the formulas can lead to inaccuracies or imbalances in token swaps and liquidity provisions.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are there rounding issues in product constant formulas?",
                        "remediation": "Review the mathematical operations in the AMM's formulas, ensuring they handle rounding appropriately without introducing vulnerabilities.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 235,
                        "category": "SOL-Defi-AS",
                        "leafId": 6,
                        "description": "Allowing arbitrary calls based on user input can expose the contract to various vulnerabilities.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can arbitrary calls be made from user input?",
                        "remediation": "Validate and sanitize user inputs. Avoid executing arbitrary calls based solely on input data.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 236,
                        "category": "SOL-Defi-AS",
                        "leafId": 7,
                        "description": "Without slippage protection, traders might experience unexpected losses due to large price deviations during a trade.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there a mechanism in place to protect against excessive slippage?",
                        "remediation": "Incorporate a slippage parameter that users can set to limit their maximum acceptable slippage.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 237,
                        "category": "SOL-Defi-AS",
                        "leafId": 8,
                        "description": "If the AMM doesn't support tokens with varying decimals or types, it might lead to incorrect calculations and potential losses.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the AMM properly handle tokens of varying decimal configurations and token types?",
                        "remediation": "Ensure compatibility with tokens of varying decimal places and validate token types before processing them.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 238,
                        "category": "SOL-Defi-AS",
                        "leafId": 9,
                        "description": "Fee-on-transfer tokens can cause problems because the sending amount and the received amount do not match.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the AMM support the fee-on-transfer tokens?",
                        "remediation": "Ensure the fee-on-transfer tokens are handled correctly if they are supposed to be supported.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 239,
                        "category": "SOL-Defi-AS",
                        "leafId": 10,
                        "description": "Rebasing tokens can change the actual balance.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the AMM support the rebasing tokens?",
                        "remediation": "Ensure the rebasing tokens are handled correctly if they are supposed to be supported.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 241,
                        "category": "SOL-Defi-AS",
                        "leafId": 11,
                        "description": "Protocols integrating AMMs should determine the `minAmountOut` prior to swaps to avoid unfavorable rates. The source of the rates and potential for manipulation should also be considered.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol calculate `minAmountOut` before a token swap?",
                        "remediation": "Ensure that the protocol calculates `minAmountOut` before executing swaps. If external oracles are used, validate their trustworthiness and consider potential vulnerabilities like sandwich attacks.",
                        "referenceList": [
                            "https://blog.chain.link/guide-to-sandwich-attacks/"
                        ],
                        "childs": []
                    },
                    {
                        "id": 240,
                        "category": "SOL-Defi-AS",
                        "leafId": 12,
                        "description": "Callback functions can be manipulated if they don't validate the calling contract's address. This is especially crucial for functions like `swap()` that involve tokens or assets.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the integrating contract verify the caller address in its callback functions?",
                        "remediation": "Implement checks in the callback functions to validate the address of the calling contract. Additionally, review the logic for any potential bypasses to this check.",
                        "referenceList": [],
                        "childs": []
                    }
                ]
            },
            {
                "id": 242,
                "category": "Lending",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 246,
                        "category": "SOL-Defi-Lending",
                        "leafId": 1,
                        "description": "Failure to liquidate positions during sharp price drops can result in substantial platform losses.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Will the liquidation process function effectively during rapid market downturns?",
                        "remediation": "Ensure robustness during extreme market conditions.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 243,
                        "category": "SOL-Defi-Lending",
                        "leafId": 2,
                        "description": "If positions cannot be liquidated under these circumstances, it poses a risk to lenders who might not recover their funds.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can a position be liquidated if the loan remains unpaid or if the collateral falls below the required threshold?",
                        "remediation": "Ensure a reliable mechanism for liquidating under-collateralized or defaulting loans to safeguard lenders.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 244,
                        "category": "SOL-Defi-Lending",
                        "leafId": 3,
                        "description": "Self-liquidation profit loopholes can lead to potential system abuse and unintended financial consequences.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is it possible for a user to gain undue profit from self-liquidation?",
                        "remediation": "Audit and test self-liquidation mechanisms to prevent any exploitative behaviors.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 245,
                        "category": "SOL-Defi-Lending",
                        "leafId": 4,
                        "description": "Unexpected pauses can place users at risk of unwarranted liquidations, despite their willingness to increase collateral.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "If token transfers or collateral additions are temporarily paused, can a user still be liquidated, even if they intend to deposit more funds?",
                        "remediation": "Implement safeguards that protect users from liquidation during operational pauses or interruptions.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 248,
                        "category": "SOL-Defi-Lending",
                        "leafId": 5,
                        "description": "Pausing liquidations can increase the solvency risk and lead to unpredictable behaviors upon resumption.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "If liquidations are temporarily suspended, what are the implications when they are resumed?",
                        "remediation": "Outline clear protocols for pausing and resuming liquidations, ensuring solvency is maintained.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 249,
                        "category": "SOL-Defi-Lending",
                        "leafId": 6,
                        "description": "Lenders must be prevented from griefing via front-running the liquidation.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is it possible for users to manipulate the system by front-running and slightly increasing their collateral to prevent liquidations?",
                        "remediation": "Ensure it is not possible to prevent liquidators by any means.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 250,
                        "category": "SOL-Defi-Lending",
                        "leafId": 7,
                        "description": "Without proper incentives, small positions might be overlooked, leading to inefficiencies.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are all positions, regardless of size, incentivized adequately for liquidation?",
                        "remediation": "Ensure a balanced incentive structure that motivates liquidators to address positions of all sizes.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 252,
                        "category": "SOL-Defi-Lending",
                        "leafId": 8,
                        "description": "Omitting interest in LTV calculations can result in inaccurate credit assessments.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is interest considered during Loan-to-Value (LTV) calculation?",
                        "remediation": "Include accrued interest in LTV calculations to maintain accurate and fair credit evaluations.",
                        "referenceList": [
                            "https://solodit.xyz/issues/h-7-users-can-be-liquidated-prematurely-because-calculation-understates-value-of-underlying-position-sherlock-blueberry-blueberry-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 253,
                        "category": "SOL-Defi-Lending",
                        "leafId": 9,
                        "description": "Protocols might need to ensure that liquidation and repaying mechanisms are either both active or inactive to maintain consistency.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can liquidation and repaying be enabled or disabled simultaneously?",
                        "remediation": "Review protocol logic to allow or disallow liquidation and repaying functions collectively to avoid operational discrepancies.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-2-liquidations-are-enabled-when-repayments-are-disabled-causing-borrowers-to-lose-funds-without-a-chance-to-repay-sherlock-blueberry-blueberry-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 254,
                        "category": "SOL-Defi-Lending",
                        "leafId": 10,
                        "description": "Protocols that allow the same token to be lent and borrowed in a single transaction may be vulnerable to attacks that exploit rapid price inflation or flash loans to manipulate the system.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is it possible to lend and borrow the same token within a single transaction?",
                        "remediation": "Protocols should implement constraints to prohibit the same token from being used in a lend and borrow action within the same block or transaction, reducing the risk of flash-loan attacks and other manipulative practices.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 247,
                        "category": "SOL-Defi-Lending",
                        "leafId": 11,
                        "description": "Discrepancies in liquidation returns can discourage liquidators and impact system stability.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there a scenario where a liquidator might receive a lesser amount than anticipated?",
                        "remediation": "Ensure a clear and consistent calculation mechanism for liquidation rewards.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 251,
                        "category": "SOL-Defi-Lending",
                        "leafId": 12,
                        "description": "Certain scenarios or conditions might prevent a user from repaying their loan, causing them to be perpetually in debt. This can be due to factors such as excessive collateralization, high fees, fluctuating token values, or other unforeseen events.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is it possible for a user to be in a condition where they cannot repay their loan?",
                        "remediation": "Review the lending protocol's logic to ensure there are no conditions that could trap a user in perpetual debt. Implement safeguards to notify or protect users from taking actions that may lead to irrecoverable financial situations.",
                        "referenceList": [],
                        "childs": []
                    }
                ]
            },
            {
                "id": 255,
                "category": "FlashLoan",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 256,
                        "category": "SOL-Defi-FlashLoan",
                        "leafId": 1,
                        "description": "Allowing withdrawals within the same block as other interactions may enable attackers to exploit flashloan vulnerabilities.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is withdraw disabled in the same block to prevent flashloan attacks?",
                        "remediation": "Implement a delay or disable withdrawals within the same block where a deposit or loan action took place to mitigate such risks.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 257,
                        "category": "SOL-Defi-FlashLoan",
                        "leafId": 2,
                        "description": "ERC4626, the tokenized vault standard, could be susceptible to flashloan attacks if the underlying mechanisms do not adequately account for such threats.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can ERC4626 be manipulated through flashloans?",
                        "remediation": "Ensure that ERC4626-related operations have in-built protections against rapid, in-block actions that could be leveraged by flashloans.",
                        "referenceList": [
                            "https://github.com/code-423n4/2022-01-behodler-findings/issues/304"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 258,
                "category": "Staking",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 259,
                        "category": "SOL-Defi-Staking",
                        "leafId": 1,
                        "description": "If users can amplify time locks for others by stacking tokens, it may lead to unintended lock durations and potentially be exploited.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can a user amplify another user's time lock duration by stacking tokens on their behalf?",
                        "remediation": "Implement strict checks and controls to prevent users from influencing the time locks of other users through token stacking.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 260,
                        "category": "SOL-Defi-Staking",
                        "leafId": 2,
                        "description": "Manipulation in the timing of reward distribution can adversely affect users and the protocol's intended incentives.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can the distribution of rewards be unduly delayed or prematurely claimed?",
                        "remediation": "Implement time controls and constraints on reward distributions to maintain the protocol's intended behavior.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 261,
                        "category": "SOL-Defi-Staking",
                        "leafId": 3,
                        "description": "The staking protocol often has a function to update the rewards (e.g. `updateRewards`) and sometimes it is used as a modifier. This update function MUST be called before all relevant operations.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are rewards up-to-date in all use-cases?",
                        "remediation": "Ensure the update reward function is called properly in all places where the reward is relevant.",
                        "referenceList": [],
                        "childs": []
                    }
                ]
            }
        ]
    },
    {
        "id": 162,
        "category": "External Call",
        "leafId": 0,
        "description": "",
        "isLeaf": false,
        "hasNoLeaf": false,
        "question": "",
        "remediation": "",
        "referenceList": [],
        "childs": [
            {
                "id": 174,
                "category": "SOL-EC",
                "leafId": 2,
                "description": "Mismanagement of `msg.value` across multiple calls can lead to vulnerabilities.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is there a multi-call?",
                "remediation": "Do not use ETH in multicall.",
                "referenceList": [
                    "https://solodit.xyz/issues/m-08-passing-multiple-eth-deposits-in-orders-array-will-use-the-same-msgvalue-many-times-code4rena-nested-finance-nested-finance-contest-git"
                ],
                "childs": []
            },
            {
                "id": 175,
                "category": "SOL-EC",
                "leafId": 3,
                "description": "A delegatecall is a low-level function call that delegates the execution of a function in another contract while maintaining the original contract's context. It can lead to critical vulnerabilities if the destination address is not secure or can be altered by an unauthorized party.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "What are the risks associated with using delegatecall in smart contracts?",
                "remediation": "Use delegatecall only with trusted contracts, and ensure that the address to be delegated to is not changeable by unauthorized users. Implement strong access controls and audit the code for potential security issues before deployment.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 434,
                "category": "SOL-EC",
                "leafId": 14,
                "description": "On interacting with external contracts, the caller becomes a new `msg.sender` instead of the original caller.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "How is the msg.sender handled?",
                "remediation": "Ensure the validation is in place to check the actor is handled correctly.",
                "referenceList": [
                    "https://solodit.xyz/issues/swapinternal-shouldnt-use-msgsender-spearbit-connext-pdf",
                    "https://solodit.xyz/issues/m-01-onlycentrifugechainorigin-cant-require-msgsender-equal-axelargateway-code4rena-centrifuge-centrifuge-git"
                ],
                "childs": []
            },
            {
                "id": 163,
                "category": "SOL-EC",
                "leafId": 4,
                "description": "Unnecessary external calls can introduce vulnerabilities.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is the external contract call necessary?",
                "remediation": "Evaluate and eliminate non-essential external contract calls.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 165,
                "category": "SOL-EC",
                "leafId": 5,
                "description": "Calling untrusted addresses can lead to malicious actions.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Has the called address been whitelisted?",
                "remediation": "Ensure that only whitelisted or trusted contract addresses are called.",
                "referenceList": [
                    "https://solodit.xyz/issues/too-generic-calls-in-genericbridgefacet-allow-stealing-of-tokens-spearbit-lifi-pdf",
                    "https://solodit.xyz/issues/hardcode-or-whitelist-the-axelar-destinationaddress-spearbit-lifi-pdf"
                ],
                "childs": []
            },
            {
                "id": 166,
                "category": "SOL-EC",
                "leafId": 6,
                "description": "Specifying fixed gas amounts can lead to out-of-gas vulnerabilities.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is there suspicion when a fixed gas amount is specified?",
                "remediation": "Use dynamic gas estimation or ensure sufficient gas is available before the call.",
                "referenceList": [
                    "https://solodit.xyz/issues/m-02-fixed-amount-of-gas-sent-in-call-may-be-insufficient-code4rena-joyn-joyn-contest-git",
                    "https://solodit.xyz/issues/a-malicious-fee-receiver-can-cause-a-denial-of-service-trailofbits-nftx-protocol-v2-pdf"
                ],
                "childs": []
            },
            {
                "id": 167,
                "category": "SOL-EC",
                "leafId": 7,
                "description": "Calls that consume all available gas can halt subsequent actions.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "What happens if the call consumes all provided gas?",
                "remediation": "Ensure enough gas is reserved for post-call tasks or use dynamic gas estimation.",
                "referenceList": [
                    "https://solodit.xyz/issues/a-malicious-fee-receiver-can-cause-a-denial-of-service-trailofbits-nftx-protocol-v2-pdf",
                    "https://solodit.xyz/issues/poison-order-that-consumes-gas-can-block-market-trades-wont-fix-consensys-0x-v3-exchange-markdown"
                ],
                "childs": []
            },
            {
                "id": 168,
                "category": "SOL-EC",
                "leafId": 8,
                "description": "Large data passed to untrusted addresses may be exploited for griefing.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is the contract passing large data to an unknown address?",
                "remediation": "Limit data passed or employ inline assembly to manage data transfer.",
                "referenceList": [
                    "https://solodit.xyz/issues/h-2-malicious-user-can-use-an-excessively-large-_toaddress-in-oftcoresendfrom-to-break-layerzero-communication-sherlock-uxd-uxd-protocol-git"
                ],
                "childs": []
            },
            {
                "id": 169,
                "category": "SOL-EC",
                "leafId": 9,
                "description": "External calls returning vast data can deplete available gas.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "What happens if the call returns vast data?",
                "remediation": "Limit or verify data size returned from external sources.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 171,
                "category": "SOL-EC",
                "leafId": 10,
                "description": "Non-library delegate calls can alter the state of the calling contract.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Are there any delegate calls to non-library contracts?",
                "remediation": "Thoroughly review and verify such delegate calls so that the delegate calls do not change the caller's state unexpectedly.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 172,
                "category": "SOL-EC",
                "leafId": 11,
                "description": "Delegate calls grant the called contract the context of the caller, risking state alterations.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is there a strict policy against delegate calls to untrusted contracts?",
                "remediation": "Restrict delegate calls to only trusted, reviewed, and audited contracts.",
                "referenceList": [
                    "https://solodit.xyz/issues/m-01-delegate-call-in-vault_execute-can-alter-vaults-ownership-code4rena-fractional-fractional-v2-contest-git"
                ],
                "childs": []
            },
            {
                "id": 173,
                "category": "SOL-EC",
                "leafId": 1,
                "description": "Reentrant calls to different functions can unpredictably alter contract states. Note that view functions should be checked as well to prevent the Readonly Reentrancy.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "What are the implications if the call reenters a different function?",
                "remediation": "Ensure the contract state is maintained reasonably during the external interactions.",
                "referenceList": [
                    "https://medium.com/@zokyo.io/read-only-reentrancy-attacks-understanding-the-threat-to-your-smart-contracts-99444c0a7334",
                    "https://solodit.xyz/issues/m-03-read-only-reentrancy-is-possible-code4rena-angle-protocol-angle-protocol-invitational-git"
                ],
                "childs": []
            },
            {
                "id": 170,
                "category": "SOL-EC",
                "leafId": 13,
                "description": "The check-effect-interaction pattern prevents reentrancy attacks.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is the check-effect-interaction pattern being utilized?",
                "remediation": "Adhere to the CEI pattern and use `reentrancyGuard` judiciously.",
                "referenceList": [
                    "https://www.geeksforgeeks.org/reentrancy-attack-in-smart-contracts/",
                    "https://solodit.xyz/issues/m-09-malicious-royalty-recipient-can-steal-excess-eth-from-buy-orders-code4rena-caviar-caviar-private-pools-git",
                    "https://solodit.xyz/issues/h-01-re-entrancy-in-settleauction-allow-stealing-all-funds-code4rena-kuiper-kuiper-contest-git"
                ],
                "childs": []
            },
            {
                "id": 164,
                "category": "SOL-EC",
                "leafId": 12,
                "description": "Calling non-existent addresses can lead to unintended behaviors. Low level calls (call, delegate call and static call) return success if the called contract doesn't exist (not deployed or destructed)",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is the address's existence verified?",
                "remediation": "Verify the existence of an address before making a call.",
                "referenceList": [
                    "https://solodit.xyz/issues/h-02-non-existing-revenue-contract-can-be-passed-to-claimrevenue-to-send-all-tokens-to-treasury-code4rena-debt-dao-debt-dao-contest-git",
                    "https://solodit.xyz/issues/m-10-call-to-non-existing-contracts-returns-success-code4rena-biconomy-biconomy-hyphen-20-contest-git",
                    "https://solodit.xyz/issues/lack-of-contract-existence-check-on-delegatecall-will-result-in-unexpected-behavior-trailofbits-degate-pdf",
                    "https://solodit.xyz/issues/m-02-solmates-erc20-does-not-check-for-token-contracts-existence-which-opens-up-possibility-for-a-honeypot-attack-code4rena-size-size-contest-git",
                    "https://solodit.xyz/issues/m-25-vault-can-be-created-for-not-yet-existing-erc20-tokens-which-allows-attackers-to-set-traps-to-steal-nfts-from-borrowers-code4rena-astaria-astaria-git",
                    "https://solodit.xyz/issues/calls-made-to-non-existentremoved-routes-or-controllers-will-not-result-in-failure-consensys-socket-markdown"
                ],
                "childs": []
            }
        ]
    },
    {
        "id": 265,
        "category": "Hash / Merkle Tree",
        "leafId": 0,
        "description": "",
        "isLeaf": false,
        "hasNoLeaf": false,
        "question": "",
        "remediation": "",
        "referenceList": [],
        "childs": [
            {
                "id": 266,
                "category": "SOL-HMT",
                "leafId": 1,
                "description": "When using a merkle tree, the new proof is calculated at a certain time and there exists a period of time between when the proof is generated and the proof is published.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is the Merkle tree vulnerable to front-running attacks?",
                "remediation": "Ensure that front-running the merkle proof setting does not affect the protocol.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 268,
                "category": "SOL-HMT",
                "leafId": 2,
                "description": "Validation of `msg.sender` is critical in the use of Merkle tree.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Does the claim method validate `msg.sender`?",
                "remediation": "Ensure that the `msg.sender` is actually the same address included in the leave.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 269,
                "category": "SOL-HMT",
                "leafId": 3,
                "description": "Passing the zero hash can lead to unintended behaviors or vulnerabilities if not properly handled.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "What is the result when passing a zero hash to the Merkle tree functions?",
                "remediation": "Implement checks to handle zero hash values appropriately and prevent potential misuse.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 270,
                "category": "SOL-HMT",
                "leafId": 4,
                "description": "Duplicate proofs within a Merkle tree can lead to double-spending or other vulnerabilities.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "What occurs if the same proof is duplicated within the Merkle tree?",
                "remediation": "Ensure the Merkle tree construction and verification process detects and prevents the use of duplicate proofs.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 267,
                "category": "SOL-HMT",
                "leafId": 5,
                "description": "Not including claimable addresses when hashing leaves can let an attacker to claim.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Are the leaves of the Merkle tree hashed with the claimable address included?",
                "remediation": "Ensure that the Merkle tree construction includes the hashing of claimable addresses within the leaves.",
                "referenceList": [],
                "childs": []
            }
        ]
    },
    {
        "id": 357,
        "category": "Heuristics",
        "leafId": 0,
        "description": "",
        "isLeaf": false,
        "hasNoLeaf": false,
        "question": "",
        "remediation": "",
        "referenceList": [],
        "childs": [
            {
                "id": 358,
                "category": "SOL-Heuristics",
                "leafId": 1,
                "description": "Inconsistent implementations of the same logic can introduce errors or vulnerabilities.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is there any logic implemented multiple times?",
                "remediation": "Standardize the logic and make it as a separate function.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 359,
                "category": "SOL-Heuristics",
                "leafId": 2,
                "description": "If a variable of nested structure is deleted, only the top-level fields are reset by default values (zero) and the nested level fields are not reset.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Does the contract use any nested structures?",
                "remediation": "Always ensure that inner fields are deleted before the outer fields of the structure.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 360,
                "category": "SOL-Heuristics",
                "leafId": 3,
                "description": "Overlooking the possibility of a sender and a recipient (source and destination) being the same in smart contracts can lead to unintended problems.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is there any unexpected behavior when `src==dst` (or `caller==receiver`)?",
                "remediation": "Ensure the protocol behaves as expected when `src==dst`.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 361,
                "category": "SOL-Heuristics",
                "leafId": 4,
                "description": "The order of modifiers can influence the behavior of a function. Generally,  NonReentrant must come first than other modifiers.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is the NonReentrant modifier placed before every other modifier?",
                "remediation": "Reorder modifiers so that NonReentrant is placed before other modifiers.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 362,
                "category": "SOL-Heuristics",
                "leafId": 5,
                "description": "A `try/catch` block without adequate gas can fail, leading to unexpected behaviors.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Does the `try/catch` block account for potential gas shortages?",
                "remediation": "Ensure sufficient gas is supplied when using the `try/catch` block.",
                "referenceList": [
                    "https://forum.openzeppelin.com/t/a-brief-analysis-of-the-new-try-catch-functionality-in-solidity-0-6/2564"
                ],
                "childs": []
            },
            {
                "id": 364,
                "category": "SOL-Heuristics",
                "leafId": 6,
                "description": "Incomplete or incorrect implementation of EIP recommendations can lead to vulnerabilities.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Did you check the relevant EIP recommendations and security concerns?",
                "remediation": "Read the recommendations and security concerns and ensure all are implemented as per the official recommendations.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 365,
                "category": "SOL-Heuristics",
                "leafId": 7,
                "description": "Off-by-one errors are not rare. Is `<=` correct in this context or should `<` be used? Should a variable be set to the length of a list or the length - 1? Should an iteration start at 1 or 0?",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Are there any off-by-one errors?",
                "remediation": "Review all usages of comparison operators for correctness.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 366,
                "category": "SOL-Heuristics",
                "leafId": 8,
                "description": "Logical operators like `==`, `!=`, `&&`, `||`, `!` can be overlooked especially when the test coverage is not good.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Are logical operators used correctly?",
                "remediation": "Review all usages of logical operators for correctness.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 369,
                "category": "SOL-Heuristics",
                "leafId": 10,
                "description": "While minor rounding errors can be inevitable in certain operations, they can pose significant issues if they can be magnified. Amplification can occur when a function is invoked multiple times strategically or under specific conditions.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Are there rounding errors that can be amplified?",
                "remediation": "Conduct thorough tests to identify and understand potential rounding errors. Ensure that they cannot be amplified to a level that would be detrimental to the system or its users. In cases where significant rounding errors are detected, the implementation should be revised to minimize or eliminate them.",
                "referenceList": [
                    "https://github.com/OpenCoreCH/smart-contract-audits/blob/main/reports/c4/rigor.md#high-significant-rounding-errors-for-interest-calculation"
                ],
                "childs": []
            },
            {
                "id": 370,
                "category": "SOL-Heuristics",
                "leafId": 11,
                "description": "Checking a variable against its default value might be used to detect initialization. If such defaults can also be valid state, it could lead to vulnerabilities.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is there any uninitialized state?",
                "remediation": "Avoid solely relying on default values to determine initialization status.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 371,
                "category": "SOL-Heuristics",
                "leafId": 12,
                "description": "Functions that should be unique per parameters set might be callable multiple times, leading to potential issues.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Can functions be invoked multiple times with identical parameters?",
                "remediation": "Ensure functions have measures to prevent repeated calls with identical or similar parameters, especially when these calls can produce adverse effects.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 372,
                "category": "SOL-Heuristics",
                "leafId": 13,
                "description": "While working with a `memory` copy for optimization, developers might overlook updating the global state.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is the global state updated correctly?",
                "remediation": "Always ensure the global state mirrors changes made in `memory`. Consider tools or extensions that can highlight discrepancies.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 373,
                "category": "SOL-Heuristics",
                "leafId": 14,
                "description": "Contracts might have special logic for ETH, like wrapping to WETH. Assuming exclusivity between handling ETH and WETH without checks can introduce errors.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is ETH/WETH handling implemented correctly?",
                "remediation": "Clearly differentiate the logic between ETH and WETH handling, ensuring no overlap or mutual exclusivity assumptions without validation.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 374,
                "category": "SOL-Heuristics",
                "leafId": 15,
                "description": "Data on the blockchain, including that marked 'private' in smart contracts, is visible to anyone who knows how to query the blockchain's state or analyze its transaction history. Private variables are not exempt from public inspection.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Does the protocol put any sensitive data on the blockchain?",
                "remediation": "Sensitive data should either be kept off-chain or encrypted before being stored on-chain. It's important to manage encryption keys securely and ensure that on-chain data does not expose private information even when encrypted, if the encryption method is weak or the keys are mishandled.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 367,
                "category": "SOL-Heuristics",
                "leafId": 9,
                "description": "Supplying unexpected addresses can lead to unintended behaviors, especially if the address points to another contract inside the same protocol.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "What happens if the protocol's contracts are inputted as if they are normal actors?",
                "remediation": "Implement checks to validate receiver addresses and ensure the protocol behaves as expected.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 363,
                "category": "SOL-Heuristics",
                "leafId": 16,
                "description": "In many projects, there should be some symmetries for different functions. For instance, a `withdraw` function should (usually) undo all the state changes of a `deposit` function and a `delete` function should undo all the state changes of the corresponding `add` function. Asymmetries in these function pairs (e.g., forgetting to unset a field or to subtract from a value) can often lead to undesired behavior. Sometimes one side of a 'pair' is missing, like missing removing from a whitelist while there is a function to add to a whitelist.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Are there any code asymmetries?",
                "remediation": "Review paired functions for symmetry and ensure they counteract each other's state changes appropriately.",
                "referenceList": [
                    "https://github.com/OpenCoreCH/smart-contract-auditing-heuristics#code-asymmetries"
                ],
                "childs": []
            },
            {
                "id": 368,
                "category": "SOL-Heuristics",
                "leafId": 17,
                "description": "Associative properties of certain financial operations suggest that performing the operation multiple times with smaller amounts should yield an equivalent outcome as performing it once with the aggregate amount. Variations might be indicative of potential issues such as rounding errors, unintended fee accumulations, or other inconsistencies.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Does calling a function multiple times with smaller amounts yield the same contract state as calling it once with the aggregate amount?",
                "remediation": "Implement tests to validate consistency. Where discrepancies exist, ensure they are intentional, minimal, and well-documented. If discrepancies are unintended, reevaluate the implementation to ensure precision and correctness.",
                "referenceList": [],
                "childs": []
            }
        ]
    },
    {
        "id": 299,
        "category": "Integrations",
        "leafId": 0,
        "description": "Possible vulnerabilities while integrating popular external protocols",
        "isLeaf": false,
        "hasNoLeaf": false,
        "question": "",
        "remediation": "",
        "referenceList": [],
        "childs": [
            {
                "id": 300,
                "category": "Gnosis Safe",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 301,
                        "category": "SOL-Integrations-GS",
                        "leafId": 1,
                        "description": "Failing to execute the Guard's hooks  (`checkTransaction()`, `checkAfterExecution()`) can bypass critical security checks implemented in those hooks.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Do your modules execute the Guard's hooks?",
                        "remediation": "Ensure that all modules correctly execute the Guard's hooks as intended.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 302,
                        "category": "SOL-Integrations-GS",
                        "leafId": 2,
                        "description": "If the nonce is not incremented in `execTransactionFromModule()`, it can cause issues when relying on it for signatures.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the `execTransactionFromModule()` function increment the nonce?",
                        "remediation": "Ensure increase nonce inside the function `execTransactionFromModule()`.",
                        "referenceList": [],
                        "childs": []
                    }
                ]
            },
            {
                "id": 303,
                "category": "LSD",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 304,
                        "category": "stETH",
                        "leafId": 0,
                        "description": "",
                        "isLeaf": false,
                        "hasNoLeaf": false,
                        "question": "",
                        "remediation": "",
                        "referenceList": [],
                        "childs": [
                            {
                                "id": 305,
                                "category": "SOL-Integrations-LSD-stETH",
                                "leafId": 1,
                                "description": "`stETH` rebases, which can introduce complexities when integrated with DeFi platforms. Using `wstETH` can simplify integrations as it is non-rebasing.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is the application aware that `stETH` is a rebasing token?",
                                "remediation": "Consider using `wstETH` for simpler DeFi integrations and to avoid complexities associated with rebasing tokens.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 307,
                                "category": "SOL-Integrations-LSD-stETH",
                                "leafId": 2,
                                "description": "Withdrawing `stETH` or `wstETH` can introduce overheads, due to various problems like queue time, receipt of an NFT, and withdrawal amount limits.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Are you aware of the overhead when withdrawing `stETH`/`wstETH`?",
                                "remediation": "Ensure account for these overheads and constraints in the protocol logic.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 306,
                                "category": "SOL-Integrations-LSD-stETH",
                                "leafId": 3,
                                "description": "Converting between `stETH` and `wstETH` can be tricky due to the rebasing nature of `stETH`. It's crucial to handle these conversions correctly to avoid potential issues.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the application handle conversions between `stETH` and `wstETH` correctly?",
                                "remediation": "Ensure that the rebasing characteristics of `stETH` are properly managed when converting between `stETH` and `wstETH`.",
                                "referenceList": [],
                                "childs": []
                            }
                        ]
                    },
                    {
                        "id": 308,
                        "category": "rETH",
                        "leafId": 0,
                        "description": "",
                        "isLeaf": false,
                        "hasNoLeaf": false,
                        "question": "",
                        "remediation": "",
                        "referenceList": [],
                        "childs": [
                            {
                                "id": 311,
                                "category": "SOL-Integrations-LSD-rETH",
                                "leafId": 2,
                                "description": "Staking on the Ethereum 2.0 Beacon Chain accrues rewards. The system should account for these rewards when dealing with `rETH`.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "How does the system manage rewards accrued from staking?",
                                "remediation": "Ensure proper distribution or accumulation of rewards in the system's `rETH` management.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 313,
                                "category": "SOL-Integrations-LSD-rETH",
                                "leafId": 4,
                                "description": "There's a risk of consensus attacks on RPL nodes where malicious nodes may submit incorrect exchange rate data, leading to discrepancies.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "What measures are in place to counteract potential consensus attacks on RPL nodes?",
                                "remediation": "Implement a system in place to quickly rectify incorrect data submissions by nodes.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 310,
                                "category": "SOL-Integrations-LSD-rETH",
                                "leafId": 1,
                                "description": "Validators on the Ethereum 2.0 Beacon Chain can be penalized or slashed for misbehavior. This can affect the value of `rETH`.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the application account for potential penalties or slashes?",
                                "remediation": "Implement mechanisms to account for potential penalties or slashes that can impact the value of `rETH`.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 312,
                                "category": "SOL-Integrations-LSD-rETH",
                                "leafId": 3,
                                "description": "If there's not enough ether in the `RocketDepositPool` contract, the `burn()` function can fail. It's important for the system to handle these failures gracefully.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Does the application handle potential reverts in the `burn()` function when there's insufficient ether in the `RocketDepositPool`?",
                                "remediation": "Ensure there's a mechanism to either prevent calls to `burn()` when there's insufficient ether or handle the revert gracefully, informing the user appropriately.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 309,
                                "category": "SOL-Integrations-LSD-rETH",
                                "leafId": 5,
                                "description": "The conversion rate between `ETH` and `rETH` might change over time based on the rewards accrued from staking. Ensure this dynamic is properly captured.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "How does the system handle the conversion between `ETH` and `rETH`?",
                                "remediation": "Integrate accurate conversion mechanisms that consider the ever-changing staking rewards when converting between `ETH` and `rETH`.",
                                "referenceList": [],
                                "childs": []
                            }
                        ]
                    },
                    {
                        "id": 314,
                        "category": "cbETH",
                        "leafId": 0,
                        "description": "",
                        "isLeaf": false,
                        "hasNoLeaf": false,
                        "question": "",
                        "remediation": "",
                        "referenceList": [],
                        "childs": [
                            {
                                "id": 315,
                                "category": "SOL-Integrations-LSD-cbETH",
                                "leafId": 1,
                                "description": "The rate between `cbETH` and `ETH` being controllable by a few addresses can introduce centralization risks and potential manipulations.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "How is the control over the `cbETH`/`ETH` rate determined? Are there specific addresses with this capability due to the `onlyOracle` modifier?",
                                "remediation": "Any address with `onlyOracle` permissions should be scrutinized and their actions should be transparent to the community.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 316,
                                "category": "SOL-Integrations-LSD-cbETH",
                                "leafId": 2,
                                "description": "The rate of `cbETH` to `ETH` can decrease, which can impact users who hold or interact with `cbETH`.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "How does the system handle potential decreases in the `cbETH`/`ETH` rate?",
                                "remediation": "Implement mechanisms to inform users about the current `cbETH`/`ETH` rate. Consider providing alerts or notifications for significant rate changes. Ensure there's a mechanism to handle or rectify situations where the rate decreases dramatically.",
                                "referenceList": [],
                                "childs": []
                            }
                        ]
                    },
                    {
                        "id": 317,
                        "category": "sfrxETH",
                        "leafId": 0,
                        "description": "",
                        "isLeaf": false,
                        "hasNoLeaf": false,
                        "question": "",
                        "remediation": "",
                        "referenceList": [],
                        "childs": [
                            {
                                "id": 318,
                                "category": "SOL-Integrations-LSD-sfrxETH",
                                "leafId": 1,
                                "description": "If `sfrxETH` detaches from `frxETH` during reward transfers, it could cause discrepancies in expected and actual values, especially if these transfers are controlled by a centralized entity like the Frax team's multi-sig contract.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "How does the system handle potential detachment of `sfrxETH` from `frxETH` during reward transfers?",
                                "remediation": "Ensure there's transparency around the actions of the Frax team's multi-sig contract. Consider mechanisms to alert users or stakeholders about discrepancies between `sfrxETH` and `frxETH`.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 319,
                                "category": "SOL-Integrations-LSD-sfrxETH",
                                "leafId": 2,
                                "description": "While the `sfrxETH`/`ETH` rate might be stable now, changes in the future could impact users and stakeholders, especially if they're not forewarned.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is the stability of the `sfrxETH`/`ETH` rate guaranteed or can it decrease in the future?",
                                "remediation": "Provide clear documentation and alerts about potential changes to the `sfrxETH`/`ETH` rate. Ensure users are informed well in advance about any planned changes that could affect the rate.",
                                "referenceList": [],
                                "childs": []
                            }
                        ]
                    }
                ]
            },
            {
                "id": 320,
                "category": "LayerZero",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 323,
                        "category": "SOL-Integrations-LayerZero",
                        "leafId": 1,
                        "description": "It's crucial that the `_debitFrom` function verifies whether the specified owner is the actual owner of the tokenId and if the sender has the correct permissions to transfer the token.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the `_debitFrom` function in ONFT properly validate token ownership and transfer permissions?",
                        "remediation": "Ensure thorough checks and validations are performed in the `_debitFrom` function to maintain token security.",
                        "referenceList": [
                            "https://composable-security.com/blog/secure-integration-with-layer-zero/"
                        ],
                        "childs": []
                    },
                    {
                        "id": 321,
                        "category": "SOL-Integrations-LayerZero",
                        "leafId": 2,
                        "description": "Using blocking mechanism can potentially lead to a Denial-of-Service (DoS) attack.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Which type of mechanism are utilized? Blocking or non-blocking?",
                        "remediation": "Consider using non-blocking mechanism to prevent potential DoS attacks.",
                        "referenceList": [
                            "https://solodit.xyz/issues/h-06-attacker-can-block-layerzero-channel-code4rena-velodrome-finance-velodrome-finance-contest-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 322,
                        "category": "SOL-Integrations-LayerZero",
                        "leafId": 3,
                        "description": "Inaccurate gas estimation can result in cross-chain message failures.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is gas estimated accurately for cross-chain messages?",
                        "remediation": "Implement mechanisms to estimate gas accurately.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 324,
                        "category": "SOL-Integrations-LayerZero",
                        "leafId": 4,
                        "description": "When inheriting LzApp, direct calls to `lzEndpoint.send` can introduce vulnerabilities. Using `_lzSend` is the recommended approach.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the `_lzSend` function correctly utilized when inheriting LzApp?",
                        "remediation": "Ensure that the `_lzSend` function is used instead of making direct calls to `lzEndpoint.send`.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 325,
                        "category": "SOL-Integrations-LayerZero",
                        "leafId": 5,
                        "description": "The User Application should include the `forceResumeReceive` function to handle unexpected scenarios and unblock the message queue when needed.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the `ILayerZeroUserApplicationConfig` interface correctly implemented?",
                        "remediation": "Implement the `ILayerZeroUserApplicationConfig` interface and ensure that the `forceResumeReceive` function is present and functional.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 326,
                        "category": "SOL-Integrations-LayerZero",
                        "leafId": 6,
                        "description": "Default configuration contracts are upgradeable by the LayerZero team.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are default contracts used?",
                        "remediation": "Configure the applications uniquely and avoid using default settings.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 327,
                        "category": "SOL-Integrations-LayerZero",
                        "leafId": 7,
                        "description": "Choosing an inappropriate number of confirmations can introduce risks, especially considering past reorg events on the chain.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the correct number of confirmations chosen for the chain?",
                        "remediation": "Evaluate the chain's history and potential vulnerabilities to determine the optimal number of confirmations.",
                        "referenceList": [],
                        "childs": []
                    }
                ]
            },
            {
                "id": 328,
                "category": "Chainlink",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 329,
                        "category": "VRF",
                        "leafId": 0,
                        "description": "",
                        "isLeaf": false,
                        "hasNoLeaf": false,
                        "question": "",
                        "remediation": "",
                        "referenceList": [],
                        "childs": [
                            {
                                "id": 331,
                                "category": "SOL-Integrations-Chainlink-VRF",
                                "leafId": 2,
                                "description": "Chainlink VRF can go into a pending state if there's insufficient LINK in the subscription. Once the subscription is refilled, the transaction can potentially be frontrun, introducing vulnerabilities.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is it guaranteed that the operator holds sufficient LINK in the subscription?",
                                "remediation": "Ensure the pending subscription does not affect the protocol's functionality.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 332,
                                "category": "SOL-Integrations-Chainlink-VRF",
                                "leafId": 3,
                                "description": "Not choosing a high enough request confirmation number can pose risks, especially in the context of chain re-orgs.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Is a sufficiently high request confirmation number chosen considering chain re-orgs?",
                                "remediation": "Evaluate the chain's vulnerability to re-orgs and adjust the request confirmation number accordingly.",
                                "referenceList": [
                                    "https://github.com/pashov/audits/blob/master/solo/NFTLoots-security-review.md#c-01-polygon-chain-reorgs-will-often-change-game-results"
                                ],
                                "childs": []
                            },
                            {
                                "id": 333,
                                "category": "SOL-Integrations-Chainlink-VRF",
                                "leafId": 4,
                                "description": "VRF calls can be frontrun and it's crucial to ensure that the user interactions are closed before the VRF call to prevent this.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Are measures in place to prevent VRF calls from being frontrun?",
                                "remediation": "Ensure the implementation closes the user interaction phase before initiating the VRF call.",
                                "referenceList": [],
                                "childs": []
                            },
                            {
                                "id": 330,
                                "category": "SOL-Integrations-Chainlink-VRF",
                                "leafId": 1,
                                "description": "If the parameters are not thoroughly verified when Chainlink VRF is called, the `fullfillRandomWord` function will not revert but return an incorrect value.",
                                "isLeaf": true,
                                "hasNoLeaf": false,
                                "question": "Are all parameters properly verified when Chainlink VRF is called?",
                                "remediation": "Ensure that all parameters passed to Chainlink VRF are verified to ensure the correct operation of `fullfillRandomWord`.",
                                "referenceList": [],
                                "childs": []
                            }
                        ]
                    }
                ]
            },
            {
                "id": 334,
                "category": "Uniswap",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 439,
                        "category": "SOL-Integrations-Uniswap",
                        "leafId": 9,
                        "description": "`pool.slot0` can be easily manipulated via flash loans to sandwich attack users.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is `pool.slot0` being used to calculate sensitive information like current price and exchange rates?",
                        "remediation": "Use UniswapV3 TWAP or Chainlink Price Oracle.",
                        "referenceList": [
                            "https://solodit.xyz/issues/h-4-no-slippage-protection-during-repayment-due-to-dynamic-slippage-params-and-easily-influenced-slot0-sherlock-real-wagmi-2-git",
                            "https://solodit.xyz/issues/h-02-use-of-slot0-to-get-sqrtpricelimitx96-can-lead-to-price-manipulation-code4rena-maia-dao-ecosystem-maia-dao-ecosystem-git",
                            "https://docs.uniswap.org/concepts/protocol/oracle"
                        ],
                        "childs": []
                    },
                    {
                        "id": 335,
                        "category": "SOL-Integrations-Uniswap",
                        "leafId": 1,
                        "description": "ON-chain slippage calculation can be manipulated.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the slippage calculated on-chain?",
                        "remediation": "Allow users to specify the slippage parameter in the actual asset amount which was calculated off-chain.",
                        "referenceList": [
                            "https://dacian.me/defi-slippage-attacks#heading-on-chain-slippage-calculation-can-be-manipulated"
                        ],
                        "childs": []
                    },
                    {
                        "id": 456,
                        "category": "SOL-Integrations-Uniswap",
                        "leafId": 10,
                        "description": "In UniswapV3 liquidity can be spread across multiple fee tiers. If a function which initiates a uni v3 swap hard-codes the fee tier parameter, this can have several negative effects.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is a hard-coded fee tier parameter being used?",
                        "remediation": "Functions allowing users to perform uni v3 swaps should allow users to pass in the fee tier parameter.",
                        "referenceList": [
                            "https://dacian.me/defi-slippage-attacks#heading-hard-coded-fee-tier-in-uniswapv3-swap"
                        ],
                        "childs": []
                    },
                    {
                        "id": 438,
                        "category": "SOL-Integrations-Uniswap",
                        "leafId": 8,
                        "description": "Enforcing slippage parameters for intermediate swaps but not the final step can result in users receiving less tokens than their specified minimum",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the slippage parameter enforced at the last step before transferring funds to users?",
                        "remediation": "Enforce slippage parameter as the last step before transferring funds to users",
                        "referenceList": [
                            "https://dacian.me/defi-slippage-attacks#heading-mintokensout-for-intermediate-not-final-amount"
                        ],
                        "childs": []
                    },
                    {
                        "id": 336,
                        "category": "SOL-Integrations-Uniswap",
                        "leafId": 2,
                        "description": "In case of failed or partially filled orders, the protocol must issue refunds to the users.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are there refunds after swaps?",
                        "remediation": "Implement a refund mechanism to handle failed or partially filled swaps.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 337,
                        "category": "SOL-Integrations-Uniswap",
                        "leafId": 3,
                        "description": "The order of `token0` and `token1` in AMM pools may vary depending on the chain, which can lead to inconsistencies.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the order of `token0` and `token1` consistent across chains?",
                        "remediation": "Always verify the order of tokens when interacting with different chains to avoid potential issues.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 338,
                        "category": "SOL-Integrations-Uniswap",
                        "leafId": 4,
                        "description": "Missing verification on the interacting pools can introduce risks.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are the pools that are being interacted with whitelisted?",
                        "remediation": "Ensure pools are whitelisted or verify the pool's factory address before any interactions.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 339,
                        "category": "SOL-Integrations-Uniswap",
                        "leafId": 5,
                        "description": "Relying on pool reserves can be risky, as they can be manipulated, especially using a flashloan.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there a reliance on pool reserves?",
                        "remediation": "Implement alternative methods or checks without relying solely on pool reserves.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 340,
                        "category": "SOL-Integrations-Uniswap",
                        "leafId": 6,
                        "description": "Directly using `pool.swap()` can bypass certain security mechanisms.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is `pool.swap()` directly used?",
                        "remediation": "Always use the Router contract to handle swaps, providing an added layer of security and standardization.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 341,
                        "category": "SOL-Integrations-Uniswap",
                        "leafId": 7,
                        "description": "Uniswap's TickMath and FullMath libraries require careful usage of `unchecked` due to solidity version specifics.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is `unchecked` used properly with Uniswap's math libraries?",
                        "remediation": "Review and test the use of `unchecked` in contracts utilizing Uniswap's math libraries to ensure safety and correctness.",
                        "referenceList": [
                            "https://solodit.xyz/issues/use-unchecked-intickmathsol-andfullmathsol-spearbit-overlay-pdf"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 342,
                "category": "AAVE / Compound",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 349,
                        "category": "SOL-Integrations-AC",
                        "leafId": 1,
                        "description": "The absence of the `underlying()` function in the cETH token contract can cause integration issues.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol use cETH token?",
                        "remediation": "Double check the protocol works as expected when integrating cETH token.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 343,
                        "category": "SOL-Integrations-AC",
                        "leafId": 2,
                        "description": "A high utilization rate can potentially mean that there aren't enough assets in the pool to allow users to withdraw their collateral.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "What happens if the utilization rate is too high, and collateral cannot be retrieved?",
                        "remediation": "Ensure that there are mechanisms to handle user withdrawal when the utilization rate is high.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 344,
                        "category": "SOL-Integrations-AC",
                        "leafId": 3,
                        "description": "If the AAVE protocol is paused, the protocol can not interact with it.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "What happens if the protocol is paused?",
                        "remediation": "Ensure the protocol behaves as expected when the AAVE protocol is paused.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 345,
                        "category": "SOL-Integrations-AC",
                        "leafId": 4,
                        "description": "Pools can be deprecated.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "What happens if the pool becomes deprecated?",
                        "remediation": "Ensure the protocol behaves as expected when the Pools are paused.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 346,
                        "category": "SOL-Integrations-AC",
                        "leafId": 5,
                        "description": "Lending and borrowing assets within the same eMode category might have rules or limitations.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "What happens if assets you lend/borrow are within the same eMode category?",
                        "remediation": "Ensure the protocol behaves as expected when interacting with assets in the same eMode category.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 347,
                        "category": "SOL-Integrations-AC",
                        "leafId": 6,
                        "description": "Flash loans can influence the pool index (a maximum of 180 flashloans can be performed within a block).",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Do flash loans on Aave inflate the pool index?",
                        "remediation": "Implement mechanisms to manage the effects of flash loans on the pool index.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 348,
                        "category": "SOL-Integrations-AC",
                        "leafId": 7,
                        "description": "Misimplementation of reward claims can lead to users not receiving their correct rewards.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol properly implement AAVE/COMP reward claims?",
                        "remediation": "Ensure a proper and tested implementation of AAVE/COMP reward claims.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 351,
                        "category": "SOL-Integrations-AC",
                        "leafId": 8,
                        "description": "Reaching the maximum debt on an isolated asset can result in denial-of-service or other limitations on user actions.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "On AAVE, what happens if a user reaches the maximum debt on an isolated asset?",
                        "remediation": "Ensure that the protocol works as expected when a user reaches the maximum debt.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 350,
                        "category": "SOL-Integrations-AC",
                        "leafId": 9,
                        "description": "Borrowing a siloed asset on Aave will prohibit users from borrowing other assets.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does borrowing an AAVE siloed asset restrict borrowing other assets?",
                        "remediation": "Make use of `getSiloedBorrowing(address asset)` to prevent unexpected problems.",
                        "referenceList": [
                            "https://docs.aave.com/developers/whats-new/siloed-borrowing"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 352,
                "category": "Balancer",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 353,
                        "category": "SOL-Integrations-Balancer",
                        "leafId": 1,
                        "description": "Balancer vault does not charge any fees for flash loans at the moment. However, it is possible Balancer implements fees for flash loans in the future.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol use the Balancer's flashloan?",
                        "remediation": "Ensure the protocol repays the fee together with the original debt on repayment in the `receiveFlashLoan` function.",
                        "referenceList": [
                            "https://solodit.xyz/issues/receiveflashloan-does-not-account-for-fees-trailofbits-none-lindy-labs-sandclock-pdf"
                        ],
                        "childs": []
                    },
                    {
                        "id": 355,
                        "category": "SOL-Integrations-Balancer",
                        "leafId": 2,
                        "description": "The price will only be updated whenever a transaction (e.g. swap) within the Balancer pool is triggered. Due to the lack of updates, the price provided by Balancer Oracle will not reflect the true value of the assets.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol use Balancer's Oracle? (getTimeWeightedAverage)",
                        "remediation": "Do not use the Balancer's oracle for any pricing.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-13-rely-on-balancer-oracle-which-is-not-updated-frequently-sherlock-notional-notional-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 356,
                        "category": "SOL-Integrations-Balancer",
                        "leafId": 3,
                        "description": "Balancer's Boosted Pool uses Phantom BPT where all pool tokens are minted at the time of pool creation and are held by the pool itself. Therefore, virtualSupply should be used instead of totalSupply to determine the amount of BPT supply in circulation.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol use Balancer's Boosted Pool?",
                        "remediation": "Ensure the protocol uses the correct function to get the total BPT supply in circulation.",
                        "referenceList": [
                            "https://solodit.xyz/issues/h-7-totalbptsupply-will-be-excessively-inflated-sherlock-notional-notional-update-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 354,
                        "category": "SOL-Integrations-Balancer",
                        "leafId": 4,
                        "description": "Balancer vault does not charge any fees for flash loans at the moment. However, it is possible Balancer implements fees for flash loans in the future.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol use Balancer vault pool liquidity status for any pricing?",
                        "remediation": "Balancer pools are susceptible to manipulation of their external queries, and all integrations must now take an extra step of precaution when consuming data. Via readonly reentrancy, an attacker can force token balances and BPT supply to be out of sync, creating very inaccurate BPT prices.",
                        "referenceList": [
                            "https://solodit.xyz/issues/h-13-balancerpairoracle-can-be-manipulated-using-read-only-reentrancy-sherlock-none-blueberry-update-git"
                        ],
                        "childs": []
                    }
                ]
            }
        ]
    },
    {
        "id": 440,
        "category": "Low Level",
        "leafId": 0,
        "description": "Vulnerabilities inherent in low-level codebases, such as contracts crafted in Huff, bytecode, and sections of inline assembly code.",
        "isLeaf": false,
        "hasNoLeaf": false,
        "question": "",
        "remediation": "",
        "referenceList": [],
        "childs": [
            {
                "id": 444,
                "category": "SOL-LL",
                "leafId": 4,
                "description": "When calling precompiled code, the call is still successful on error or failure. A failed precompile call simply has a return data size of 0.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is there a check on the return data size when calling precompiled code?",
                "remediation": "Check the return data size not the success of the call to determine if it failed.",
                "referenceList": [
                    "https://github.com/AmadiMichael/LowLevelVulnerabilities?tab=readme-ov-file#when-calling-precompiles-check-the-returndatasize-not-the-success-of-the-call-to-determine-if-it-failed"
                ],
                "childs": []
            },
            {
                "id": 441,
                "category": "SOL-LL",
                "leafId": 1,
                "description": "In low-level, data size is not checked by default and it can affect the unintended memory locations.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is there validation on the size of the input data?",
                "remediation": "Validate that inputs do not exceed the size of it's expected type and either revert or clean the unused bits depending on your use case before using that value.",
                "referenceList": [
                    "https://github.com/AmadiMichael/LowLevelVulnerabilities?tab=readme-ov-file#validate-all-input-bit-size"
                ],
                "childs": []
            },
            {
                "id": 442,
                "category": "SOL-LL",
                "leafId": 2,
                "description": "It is expected to revert if there is no matching function signature in the contract. Overlooking this can let the execution continue into other parts of the unintended bytecode.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "What happens if there is no matching function signature?",
                "remediation": "Ensure that the code reverts after comparing all supported function signatures, fallback etc and not matching any.",
                "referenceList": [
                    "https://github.com/AmadiMichael/LowLevelVulnerabilities?tab=readme-ov-file#end-execution-after-function-dispatching"
                ],
                "childs": []
            },
            {
                "id": 443,
                "category": "SOL-LL",
                "leafId": 3,
                "description": "Calling an address without code is always successful.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is it checked if the target address of a call has the code?",
                "remediation": "Ensure that addresses being called, static-called or delegate-called have code deployed.",
                "referenceList": [
                    "https://github.com/AmadiMichael/LowLevelVulnerabilities?tab=readme-ov-file#ensure-that-addresses-being-called-static-called-or-delegate-called-have-code-deployed-to-them"
                ],
                "childs": []
            },
            {
                "id": 445,
                "category": "SOL-LL",
                "leafId": 5,
                "description": "At the evm level and in yul/inline assembly, when dividing or modulo'ing by 0, It does not revert with Panic(18) as solidity would do, its result 0. If this behavior is not desired it should be checked. Basically, x / 0 = 0 and x % 0 = 0.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is there a non-zero check for the denominator?",
                "remediation": "Check if the denominator is zero before division.",
                "referenceList": [
                    "https://github.com/AmadiMichael/LowLevelVulnerabilities?tab=readme-ov-file#when-dividing-or-moduloin-check-that-the-denominator-is-not-0"
                ],
                "childs": []
            }
        ]
    },
    {
        "id": 286,
        "category": "Multi-chain/Cross-chain",
        "leafId": 0,
        "description": "",
        "isLeaf": false,
        "hasNoLeaf": false,
        "question": "",
        "remediation": "",
        "referenceList": [],
        "childs": [
            {
                "id": 287,
                "category": "SOL-McCc",
                "leafId": 1,
                "description": "Block time can vary across different chains, leading to potential timing discrepancies.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Are there hardcoded time values dependent on the `block.number`?",
                "remediation": "Avoid hardcoding time values based on block numbers.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 298,
                "category": "SOL-McCc",
                "leafId": 2,
                "description": "Understanding the differences between chains is vital for ensuring compatibility and preventing unexpected behaviors.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Has the protocol been checked for the target chain differences?",
                "remediation": "Regularly check for chain differences and update the protocol accordingly.",
                "referenceList": [
                    "https://www.evmdiff.com/diff?base=1&target=10",
                    "https://github.com/0xJuancito/multichain-auditor#differences-from-ethereum"
                ],
                "childs": []
            },
            {
                "id": 290,
                "category": "SOL-McCc",
                "leafId": 3,
                "description": "Incompatibility can arise when the protocol uses EVM operations not supported on certain chains.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Are the EVM opcodes and operations used by the protocol compatible across all targeted chains?",
                "remediation": "Review and ensure compatibility for chains like Arbitrum and Optimism.",
                "referenceList": [
                    "https://docs.arbitrum.io/solidity-support",
                    "https://community.optimism.io/docs/developers/build/differences/#transaction-costs"
                ],
                "childs": []
            },
            {
                "id": 291,
                "category": "SOL-McCc",
                "leafId": 4,
                "description": "Different chains might interpret these values differently, leading to unexpected behaviors.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Does the expected behavior of `tx.origin` and `msg.sender` remain consistent across all deployment chains?",
                "remediation": "Test and verify the behavior on all targeted chains.",
                "referenceList": [
                    "https://community.optimism.io/docs/developers/build/differences/#opcode-differences"
                ],
                "childs": []
            },
            {
                "id": 292,
                "category": "SOL-McCc",
                "leafId": 5,
                "description": "Some attacks become viable with low gas costs or when a large number of transactions can be processed.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is there any possibility of exploiting low gas fees to execute many transactions?",
                "remediation": "Evaluate and mitigate potential attack vectors associated with gas fees.",
                "referenceList": [
                    "https://github.com/0xJuancito/multichain-auditor#gas-fees"
                ],
                "childs": []
            },
            {
                "id": 293,
                "category": "SOL-McCc",
                "leafId": 6,
                "description": "Decimals in ERC20 tokens can differ across chains.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is there consistency in ERC20 decimals across chains?",
                "remediation": "Ensure consistent ERC20 decimals or implement chain-specific adjustments.",
                "referenceList": [
                    "https://github.com/0xJuancito/multichain-auditor#erc20-decimals"
                ],
                "childs": []
            },
            {
                "id": 294,
                "category": "SOL-McCc",
                "leafId": 7,
                "description": "Contracts may have different upgradability properties depending on the chain, like USDT being upgradable on Polygon but not on Ethereum.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Have contract upgradability implications been evaluated on different chains?",
                "remediation": "Verify and document upgradability characteristics for each chain.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 295,
                "category": "SOL-McCc",
                "leafId": 8,
                "description": "Cross-chain messaging requires robust security checks to ensure the correct permissions and intended functionality.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Have cross-chain messaging implementations been thoroughly reviewed for permissions and functionality?",
                "remediation": "Double check the access control over cross-chain messaging components.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 296,
                "category": "SOL-McCc",
                "leafId": 9,
                "description": "Allowing messages from an unsupported chain can lead to unpredictable results.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is there a whitelist of compatible chains?",
                "remediation": "Implement a whitelist to prevent messages from unsupported chains.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 297,
                "category": "SOL-McCc",
                "leafId": 10,
                "description": "zkSync Era might have specific requirements or differences when compared to standard Ethereum deployments.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Have contracts been checked for compatibility when deployed to the zkSync Era?",
                "remediation": "Review and ensure compatibility before deploying contracts to zkSync Era.",
                "referenceList": [
                    "https://era.zksync.io/docs/reference/architecture/differences-with-ethereum.html"
                ],
                "childs": []
            },
            {
                "id": 288,
                "category": "SOL-McCc",
                "leafId": 11,
                "description": "Inconsistent block production can lead to unexpected application behaviors.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is block production consistency ensured?",
                "remediation": "Develop with the assumption that block production may not always be consistent.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 289,
                "category": "SOL-McCc",
                "leafId": 12,
                "description": "`PUSH0` might not be supported on all chains, leading to potential incompatibility issues.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is `PUSH0` opcode supported for Solidity version `>=0.8.20`?",
                "remediation": "Ensure if `PUSH0` is supported in the target chain.",
                "referenceList": [
                    "https://github.com/0xJuancito/multichain-auditor#support-for-the-push0-opcode"
                ],
                "childs": []
            }
        ]
    },
    {
        "id": 271,
        "category": "Signature",
        "leafId": 0,
        "description": "",
        "isLeaf": false,
        "hasNoLeaf": false,
        "question": "",
        "remediation": "",
        "referenceList": [],
        "childs": [
            {
                "id": 273,
                "category": "SOL-Signature",
                "leafId": 2,
                "description": "Signature malleability can be exploited by attackers to produce valid signatures without the private key. Using outdated versions of libraries can introduce known vulnerabilities.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Are signatures protected against malleability issues?",
                "remediation": "Avoid using `ecrecover()` for signature verification. Instead, utilize the OpenZeppelin's latest version of ECDSA to ensure signatures are safe from malleability issues.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 274,
                "category": "SOL-Signature",
                "leafId": 3,
                "description": "Mismatched public keys can indicate an incorrect or malicious signer, potentially leading to unauthorized actions.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Does the returned public key from the signature verification match the expected public key?",
                "remediation": "Implement rigorous checks to ensure the public key derived from a signature matches the expected signer's public key.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 275,
                "category": "SOL-Signature",
                "leafId": 4,
                "description": "If signatures aren't properly checked, malicious actors might exploit them, leading to unauthorized transactions or actions.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Is the signature originating from the appropriate entity?",
                "remediation": "Ensure strict verification mechanisms are in place to confirm that signatures originate from the expected entities.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 276,
                "category": "SOL-Signature",
                "leafId": 5,
                "description": "Signatures with expiration dates that aren't checked can be reused maliciously after they should no longer be valid.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "If the signature has a deadline, is it still valid?",
                "remediation": "Always check the expiration date of signatures and ensure they're not accepted past their valid period.",
                "referenceList": [],
                "childs": []
            },
            {
                "id": 272,
                "category": "SOL-Signature",
                "leafId": 1,
                "description": "Lacking protection mechanisms like `nonce` and `block.chainid` can make signatures vulnerable to replay attacks. Also, EIP-712 provides a standard for creating typed and structured data to be signed, ensuring better security and user experience.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Are signatures guarded against replay attacks?",
                "remediation": "Implement a `nonce` system and incorporate `block.chainid` in your signature scheme. Ensure adherence to EIP-712 for all signatures.",
                "referenceList": [],
                "childs": []
            }
        ]
    },
    {
        "id": 263,
        "category": "Timelock",
        "leafId": 0,
        "description": "",
        "isLeaf": false,
        "hasNoLeaf": false,
        "question": "",
        "remediation": "",
        "referenceList": [],
        "childs": [
            {
                "id": 264,
                "category": "SOL-Timelock",
                "leafId": 1,
                "description": "Immediate changes in the protocol can affect the users.",
                "isLeaf": true,
                "hasNoLeaf": false,
                "question": "Are timelocks implemented for important changes?",
                "remediation": "Implement timelocks for important changes, allowing users adequate time to respond to proposed alterations.",
                "referenceList": [],
                "childs": []
            }
        ]
    },
    {
        "id": 406,
        "category": "Token",
        "leafId": 0,
        "description": "",
        "isLeaf": false,
        "hasNoLeaf": false,
        "question": "",
        "remediation": "",
        "referenceList": [],
        "childs": [
            {
                "id": 424,
                "category": "Non-fungible : ERC721/1155",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 425,
                        "category": "SOL-Token-NfE1",
                        "leafId": 1,
                        "description": "According to the ERC721 standard, a wallet/broker/auction application MUST implement the wallet interface if it will accept safe transfers. Use safe version of mint and transfer functions to prevent NFT being lost. (the similar applies to ERC1155)",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "How are the minting and transfer implemented?",
                        "remediation": "Use OpenZeppelin's safe mint/transfer functions for ERC721/1155.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 427,
                        "category": "SOL-Token-NfE1",
                        "leafId": 3,
                        "description": "The `safeTransferFrom` functions in OpenZeppelin's ERC721 and ERC1155 can expose the contract to reentrancy attacks due to external calls to user addresses.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the OpenZeppelin implementation of ERC721 and ERC1155 safeguarded against reentrancy attacks, especially in the `safeTransferFrom` functions?",
                        "remediation": "Use the checks-effects-interactions pattern and implement reentrancy guards to prevent potential reentrancy attacks when making external calls.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 428,
                        "category": "SOL-Token-NfE1",
                        "leafId": 4,
                        "description": "Most of the time the `from` parameter of `transferFrom()` should be `msg.sender`. Otherwise an attacker can take advantage of other user's approvals and steal.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is it possible to steal NFT abusing his approval?",
                        "remediation": "Ensure that the contract verifies the `msg.sender` is actually the owner.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 431,
                        "category": "SOL-Token-NfE1",
                        "leafId": 7,
                        "description": "For many NFT collections, a kind of privilege is provided in various ways, e.g. airdrop. The NFT owner must be able to claim the benefits while they lock in protocols.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "What happens to the airdrops that are engaged to specific NFT?",
                        "remediation": "Ensure the NFT holders can claim all benefits.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-04-its-possible-to-swap-nft-token-ids-without-fee-and-also-attacker-can-wrap-unwrap-all-the-nft-token-balance-of-the-pair-contract-and-steal-their-air-drops-for-those-token-ids-code4rena-caviar-caviar-contest-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 432,
                        "category": "SOL-Token-NfE1",
                        "leafId": 8,
                        "description": "CryptoPunks collections that do not support the `transferFrom()` function can present risks. The `offerPunkForSaleToAddress()` function in particular can be susceptible to front-running attacks, which can compromise the ownership and security of the token.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "How is the approval/transfer handled for CryptoPunks collection?",
                        "remediation": "Ensure validation is done properly to prevent malicious actors claiming the ownership.",
                        "referenceList": [
                            "https://solodit.xyz/issues/h-3-cryptopunks-nfts-may-be-stolen-via-deposit-frontrunning-sherlock-ajna-ajna-git",
                            "https://solodit.xyz/issues/h-02-anyone-can-steal-cryptopunk-during-the-deposit-flow-to-wpunkgateway-code4rena-paraspace-paraspace-contest-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 430,
                        "category": "SOL-Token-NfE1",
                        "leafId": 6,
                        "description": "To facilitate broader compatibility and usage in various applications, contracts may need to support both ERC721 and ERC1155 token standards.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can the contract support both ERC721 and ERC1155 standards?",
                        "remediation": "Use the supportsInterface method to check for and support interfaces of both ERC1155 and ERC721 within the same contract.",
                        "referenceList": [
                            "https://solodit.xyz/issues/h-06-some-real-world-nft-tokens-may-support-both-erc721-and-erc1155-standards-which-may-break-infinityexchange_transfernfts-code4rena-infinity-nft-marketplace-infinity-nft-marketplace-contest-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 426,
                        "category": "SOL-Token-NfE1",
                        "leafId": 2,
                        "description": "By standard, the token receiver contracts implement onERC721Received and onERC1155Received and this can potentially be a source of reentrancy attacks if not correctly handled.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the contract safe from reentrancy attack?",
                        "remediation": "Double check the potential reentrancy attack.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 429,
                        "category": "SOL-Token-NfE1",
                        "leafId": 5,
                        "description": "Contracts must properly implement the supportsInterface function to ensure they comply with ERC721/1155 standards and interoperate with other contracts correctly.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the ERC721/1155 contract correctly implement supportsInterface?",
                        "remediation": "Implement the supportsInterface function to return true for ERC721 and ERC1155 token types, ensuring accurate reporting of supported features.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-04-the-ferc1155sol-dont-respect-the-eip2981-code4rena-fractional-fractional-v2-contest-git"
                        ],
                        "childs": []
                    }
                ]
            },
            {
                "id": 407,
                "category": "Fungible : ERC20",
                "leafId": 0,
                "description": "",
                "isLeaf": false,
                "hasNoLeaf": false,
                "question": "",
                "remediation": "",
                "referenceList": [],
                "childs": [
                    {
                        "id": 408,
                        "category": "SOL-Token-FE",
                        "leafId": 1,
                        "description": "Not all ERC20 tokens are compliant to the EIP20 standard. Some do not return boolean flag, some do not revert on failure.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Are safe transfer functions used throughout the contract?",
                        "remediation": "Use OpenZeppelin's SafeERC20 where the safeTransfer and safeTransferFrom functions handle the return value check as well as non-standard-compliant tokens.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 411,
                        "category": "SOL-Token-FE",
                        "leafId": 4,
                        "description": "Tokens that have address checks can lead to various problems.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the token implement any form of address whitelisting, blacklisting, or checks?",
                        "remediation": "Ensure the token's own blacklisting mechanism does not affect the protocol's functionality.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 410,
                        "category": "SOL-Token-FE",
                        "leafId": 3,
                        "description": "Different decimals in ERC20 tokens can cause incorrect calculations or interpretations.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Could a difference in decimals between ERC20 tokens cause issues?",
                        "remediation": "Always check and handle the decimals of ERC20 tokens to prevent potential issues.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 421,
                        "category": "SOL-Token-FE",
                        "leafId": 14,
                        "description": "Some tokens don't support approve `type(uint256).max` amount and revert.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there a max approval used?",
                        "remediation": "Avoid approval of `type(uint256).max`.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-3-universalapprovemax-will-not-work-for-some-tokens-that-dont-support-approve-typeuint256max-amount-sherlock-dodo-dodo-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 423,
                        "category": "SOL-Token-FE",
                        "leafId": 16,
                        "description": "Allowance should not be decreased in a transferFrom() call if the sender is the same as the caller, to prevent incorrect balance and allowance tracking.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the decrease allowance feature of transferFrom() handled correctly when the sender is the caller?",
                        "remediation": "Ensure that the smart contract logic maintains correct allowance levels when transferFrom() involves the token owner themselves.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-2-transferfrom-uses-allowance-even-if-spender-from-sherlock-surge-surge-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 412,
                        "category": "SOL-Token-FE",
                        "leafId": 5,
                        "description": "Some tokens have multiple addresses and this can introduce vulnerabilities.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Could the use of multiple addresses for a single token lead to complications?",
                        "remediation": "Do not rely on the token address in the accounting.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 409,
                        "category": "SOL-Token-FE",
                        "leafId": 2,
                        "description": "Race condition for approvals can cause an unexpected loss of funds to the signer.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there potential for a race condition for approvals?",
                        "remediation": "Use OpenZeppelin's safeIncreaseAllowance and safeDecreaseAllowance functions.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m01-approval-process-can-be-front-run-openzeppelin-notional-governance-contracts-v2-audit-markdown"
                        ],
                        "childs": []
                    },
                    {
                        "id": 420,
                        "category": "SOL-Token-FE",
                        "leafId": 13,
                        "description": "Some ERC20 tokens do not work when changing the allowance from an existing non-zero allowance value. For example Tether (USDT)'s approve() function will revert if the current approval is not zero, to protect against front-running changes of approvals.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there a direct approval to a non-zero value?",
                        "remediation": "Set the allowance to zero before increasing the allowance and use safeApprove/safeIncreaseAllowance.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-17-did-not-approve-to-zero-first-sherlock-notional-notional-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 413,
                        "category": "SOL-Token-FE",
                        "leafId": 6,
                        "description": "Some tokens charge fee on transfer and the receiver gets less amount than specified.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the token charge fee on transfer?",
                        "remediation": "If the protocol intends to support this kind of token, ensure the accounting logic is correct.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 414,
                        "category": "SOL-Token-FE",
                        "leafId": 7,
                        "description": "ERC777 tokens have hooks that execute code before and after transfers, which might lead to reentrancy.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can the token be ERC777?",
                        "remediation": "Be cautious when integrating with ERC777 and be aware of the hook implications.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 415,
                        "category": "SOL-Token-FE",
                        "leafId": 8,
                        "description": "Solmate `ERC20.safeTransferLib` do not check the contract existence and this opens up a possibility for a honeypot attack.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Does the protocol use Solmate's `ERC20.safeTransferLib`?",
                        "remediation": "Use OpenZeppelin's SafeERC20.",
                        "referenceList": [
                            "https://solodit.xyz/issues/m-02-solmates-erc20-does-not-check-for-token-contracts-existence-which-opens-up-possibility-for-a-honeypot-attack-code4rena-size-size-contest-git"
                        ],
                        "childs": []
                    },
                    {
                        "id": 416,
                        "category": "SOL-Token-FE",
                        "leafId": 9,
                        "description": "Flash mints can drastically increase token supply temporarily, leading to potential abuse.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is there a flash-mint functionality?",
                        "remediation": "Implement strict controls and checks around any flash mint functionality.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 417,
                        "category": "SOL-Token-FE",
                        "leafId": 10,
                        "description": "Some tokens revert on transfer of zero amount and can cause issues in certain integrations and operations.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "What happens on zero amount transfer?",
                        "remediation": "Transfer only when the amount is positive.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 418,
                        "category": "SOL-Token-FE",
                        "leafId": 11,
                        "description": "Missing `DOMAIN_SEPARATOR()` can lead to vulnerabilities in the ERC2612 permit functionality.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Is the token an ERC2612 implementation?",
                        "remediation": "Ensure complete and correct implementation of ERC2612, including the `DOMAIN_SEPARATOR()` function.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 419,
                        "category": "SOL-Token-FE",
                        "leafId": 12,
                        "description": "Certain addresses might be blocked or restricted to receive tokens (e.g. LUSD).",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can the token be sent to any address?",
                        "remediation": "Ensure the receiver blacklisting does not affect the protocol's functionality.",
                        "referenceList": [],
                        "childs": []
                    },
                    {
                        "id": 422,
                        "category": "SOL-Token-FE",
                        "leafId": 15,
                        "description": "Some ERC20 tokens can be paused by the contract owner.",
                        "isLeaf": true,
                        "hasNoLeaf": false,
                        "question": "Can the token be paused?",
                        "remediation": "Ensure the protocol is not affected when the token is paused.",
                        "referenceList": [],
                        "childs": []
                    }
                ]
            }
        ]
    }
]